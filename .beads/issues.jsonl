{"id":"ef-0pd","title":"DRY up tool handler boilerplate with macro/helper","description":"Many handlers in efrit-do-handlers.el follow identical patterns:\n\n```elisp\n(defun efrit-do--handle-FOO (tool-input)\n  (require 'efrit-tool-foo)\n  (or (efrit-do--validate-hash-table tool-input \"foo\")\n      (efrit-do--validate-required tool-input \"foo\" \"field1\")\n      (let* ((args (efrit-do--extract-fields tool-input '(\"field1\" \"field2\")))\n             (result (efrit-tool-foo args)))\n        (efrit-do--format-tool-result result \"Foo Result\"))))\n```\n\nThis is repeated for ~20 tools: web_search, fetch_url, read_file, edit_file, create_file, vcs_*, etc.\n\nCreate a macro or helper:\n\n```elisp\n(defmacro efrit-define-simple-tool-handler\n    (fn-name tool-name required-fields field-specs underlying-fn label \u0026optional require-lib)\n  ...)\n```\n\nThen replace boilerplate handlers with one-liners.\n\nFile affected:\n- lisp/interfaces/efrit-do-handlers.el (reduce from 879 to ~500 lines)","acceptance_criteria":"1. Macro defined for simple tool handlers\n2. At least 15 handlers converted to macro usage\n3. Easier to add new tools - single line per simple tool\n4. Byte-compile warnings unchanged or improved","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.240879-08:00","updated_at":"2025-12-02T23:11:46.450225-08:00"}
{"id":"ef-15l","title":"Unify retry \u0026 rate-limit configuration across modules","description":"Duplicate and mode-specific retry/limit knobs:\n\nChat mode:\n- efrit-max-retries\n- efrit-retry-on-errors\n\nDo mode:\n- efrit-do-max-retries\n- efrit-do-retry-on-errors\n\nTools:\n- efrit-tools-max-eval-per-session\n- efrit-tools-max-total-calls-per-session\n\nExecutor:\n- efrit-executor-max-continuations\n- efrit-executor-max-tool-calls\n- efrit-executor-session-timeout\n\nConsolidate in efrit-config.el (or new efrit-limits.el):\n- efrit-tool-max-retries (shared default: 3)\n- efrit-tool-retry-on-errors (shared default: t)\n- efrit-tool-max-calls-per-session (shared)\n- efrit-session-timeout (shared)\n\nHave each module use these shared values or bind local overrides.\n\nFiles affected:\n- lisp/core/efrit-config.el\n- lisp/core/efrit-chat-api.el\n- lisp/interfaces/efrit-do.el\n- lisp/core/efrit-tools.el\n- lisp/core/efrit-executor.el","acceptance_criteria":"1. Fewer total defcustom variables for limits/retries\n2. Consistent behavior between chat and do modes\n3. Single place to configure session safety limits","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.23098-08:00","updated_at":"2025-12-02T21:58:07.23098-08:00"}
{"id":"ef-1lu","title":"Chat advertises full efrit-do tools but only implements 7 - returns \"Unknown tool\" errors","description":"CRITICAL FOR PRODUCTION:\n\nefrit-chat-api.el sends the full efrit-do tool schema to Claude:\n(\"tools\" . ,(efrit-do--get-current-tools-schema))\n\nBut the actual tool handlers only support 7 tools:\n1. eval_sexp\n2. get_context\n3. read_image\n4. create_buffer\n5. edit_buffer\n6. read_buffer\n7. buffer_info\n\nAll other tools (project_files, search_content, read_file, edit_file, create_file, vcs_*, checkpoints, etc.) will return \"Error: Unknown tool\" when Claude tries to use them.\n\nThis creates terrible UX where:\n1. Claude *believes* it can call 30+ tools in chat\n2. Most calls fail with confusing errors\n3. Users burn tokens on retries\n\nFIX OPTIONS:\nA) Delegate unknown tools to efrit-do--dispatch-tool (simple path)\nB) Restrict chat schema to only the 7 implemented tools (fast fix)\nC) Full unification of tool execution between chat and efrit-do","acceptance_criteria":"1. efrit-chat either supports all advertised tools OR only advertises tools it can execute\n2. No \"Unknown tool\" errors when using efrit-chat with tools in the schema","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-02T21:47:44.985623-08:00","updated_at":"2025-12-02T21:52:40.646183-08:00","closed_at":"2025-12-02T21:52:40.646183-08:00"}
{"id":"ef-1s7","title":"Verify efrit-chat has same tool access as efrit-do","description":"User requirement: efrit-chat should have access to all the same tools as efrit-do for quick one-off tasks.\n\nCurrent status:\n- efrit-do has 34 tools via efrit-do-schema.el\n- efrit-chat uses its own tool definitions (need to verify if same)\n- Need to confirm parity and identify any gaps\n\nKey questions:\n1. Does efrit-chat send the same tool schema to Claude?\n2. Are all tools like eval_sexp, shell_exec, todo_write available in chat?\n3. Any tools in efrit-do missing from efrit-chat?\n4. Any tools in efrit-chat missing from efrit-do (that shouldn't be)?","acceptance_criteria":"Document which tools are available in both systems, identify any tool gaps, and ensure feature parity for one-off tasks","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:40.938928-08:00","updated_at":"2025-12-02T18:14:55.124961-08:00","closed_at":"2025-12-02T18:14:55.124961-08:00"}
{"id":"ef-2c1","title":"Unify tool_result building across chat and executor","description":"Tool result packaging is duplicated and inconsistent:\n\nefrit-chat-api.el:\n- efrit--build-tool-result (handles image results and text)\n\nefrit-executor.el:\n- efrit-executor--process-sync-content builds tool_result blocks ad-hoc\n- efrit-session-build-tool-result used in async path\n\nTools return different shapes:\n- Text strings with embedded markers ([SESSION-COMPLETE: ...], [WAITING-FOR-USER])\n- JSON-encoded payloads wrapped by efrit-do--format-tool-result\n- Image results as ((image . ...)) alists\n\nCreate efrit-tool-runtime.el (or add to efrit-common.el):\n```elisp\n(defun efrit-tool-build-result-block (tool-id result \u0026optional is-error)\n  \"Return a tool_result block suitable for Anthropic's messages API.\"\n  ...)\n```\n\nUse this single function in both chat and executor paths.\n\nFiles affected:\n- lisp/core/efrit-chat-api.el (efrit--build-tool-result)\n- lisp/core/efrit-executor.el (tool_result building)\n- lisp/core/efrit-session.el (efrit-session-build-tool-result)","acceptance_criteria":"1. Single tool_result building function used everywhere\n2. Consistent handling of image, text, and error results\n3. Session-control markers documented as part of tool contract","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.250076-08:00","updated_at":"2025-12-02T21:58:07.250076-08:00"}
{"id":"ef-2ia","title":"Standardize parameter naming (issue-id vs issue_id) in beads tools","description":"Inconsistent parameter naming between elisp (issue-id with hyphen) and JSON schemas (issue_id with underscore). Pick one convention and apply consistently.","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:08:47.150312-08:00","updated_at":"2025-12-02T21:34:00.327795-08:00","closed_at":"2025-12-02T21:34:00.327795-08:00"}
{"id":"ef-3pw","title":"Verify error handling and recovery in efrit-do async","description":"User requirement: Error handling must be solid for prime-time release.\n\nAreas to test:\n1. API errors (timeout, rate limit, auth failure) - should not crash, should show clear error\n2. Tool execution errors (bad elisp syntax, command not found) - should be caught and reported\n3. Circuit breaker trips - should show reason and allow recovery\n4. Session interruption (C-g) - should cleanup gracefully\n5. Recovery from errors - can Claude recover or does session need restart?\n\nCurrent implementation:\n- efrit-do--extract-error-info exists for error detection\n- efrit-do--build-error-context exists for context\n- Circuit breaker configured with limits\n- But integration testing needed\n\nTesting needed:\n1. Test bad elisp: (eval_sexp \"invalid lisp\")\n2. Test missing command: (shell_exec \"nonexistent_command\")\n3. Test timeout behavior\n4. Test session interruption\n5. Test recovery from transient errors","acceptance_criteria":"All error scenarios handled gracefully without crashing Emacs. Errors should be clearly displayed in progress buffer. Session should be recoverable or cleanly terminated.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:45.578341-08:00","updated_at":"2025-12-02T20:53:34.563982-08:00","closed_at":"2025-12-02T20:53:34.563982-08:00"}
{"id":"ef-4z6","title":"Extract tool dispatch runtime from efrit-do.el to efrit-do-dispatch.el","description":"efrit-do.el (1628 lines) mixes too many concerns:\n- User commands and customization\n- Tool dispatch table and runtime\n- Prompt construction\n- Context and TODO management\n\nefrit-chat-api.el and efrit-executor.el reach into efrit-do for tool execution, creating tight coupling and potential circular dependencies.\n\nExtract to efrit-do-dispatch.el:\n- efrit-do--tool-dispatch-table\n- efrit-do--dispatch-tool\n- efrit-do--execute-tool\n- Pure helpers used only by these (sanitization, error extraction)\n\nThen efrit-chat-api.el and efrit-executor.el can require efrit-do-dispatch instead of efrit-do.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (extract ~200 lines)\n- lisp/core/efrit-chat-api.el (change declare-function)\n- lisp/core/efrit-executor.el (change require)","acceptance_criteria":"1. New efrit-do-dispatch.el with tool dispatch table and execution\n2. efrit-do.el reduced to user-facing commands and state management\n3. efrit-chat-api.el requires efrit-do-dispatch not efrit-do\n4. No circular dependency warnings from byte-compile","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.196113-08:00","updated_at":"2025-12-02T22:47:35.926289-08:00","closed_at":"2025-12-02T22:47:35.926289-08:00"}
{"id":"ef-574","title":"Update README: version mismatch and incomplete tool table","description":"README is out of date:\n\n1. Version shows 0.4.0, code is at 0.4.1\n2. Advertises \"15+ tools\" but efrit-do-schema.el defines ~34 tools\n3. Missing tool categories: todo_write, get_diagnostics, beads_*, checkpoint/restore, show_diff_preview, read_image, format_file, undo_edit","acceptance_criteria":"1. Version updated to 0.4.1 everywhere\n2. Tool table expanded to show all major categories","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:47:45.019345-08:00","updated_at":"2025-12-02T22:06:24.445166-08:00","closed_at":"2025-12-02T22:06:24.445166-08:00"}
{"id":"ef-5t5","title":"Add Claude Code migration guide for Emacs users","description":"For users coming from Claude Code, there's no guide mapping concepts:\n\nClaude Code → Efrit equivalent:\n- Chat sidebar → efrit-chat (limited) or efrit-do (full)\n- Project tools → efrit-do tools (not in chat currently)\n- Diff preview → show_diff_preview tool\n- Agent view → efrit-agent buffer\n- Progress view → Efrit Progress buffer\n- AI-to-AI → Remote queue (MCP)\n\nShould also note what's not yet available.","acceptance_criteria":"Documentation exists mapping Claude Code concepts to Efrit equivalents","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-02T21:47:45.05794-08:00","updated_at":"2025-12-02T21:47:45.05794-08:00"}
{"id":"ef-8o0","title":"Potential timer leak in file watcher callbacks (efrit-remote-queue.el)","description":"In efrit-remote-queue.el line 526, each file system event creates a fire-and-forget timer with run-at-time. Under heavy file I/O or rapid file writes, this could accumulate timer objects that are never tracked or explicitly canceled.\n\nThe timer pattern:\n```\n(run-at-time 0.1 nil #'efrit-remote-queue--process-file file-path)\n```\n\nThis is a one-shot timer (interval=nil), but:\n1. Not tracked in any hash table or variable\n2. Called from a file watcher callback that fires on every file event\n3. Could accumulate hundreds of timers if files are written rapidly\n\nPotential solutions:\n1. Add a debounce mechanism to prevent multiple timers for the same file\n2. Use a timer tracking hash table like async-loop uses\n3. Add a maximum pending timers guard\n\nNote: Low risk since each timer is one-shot, but could affect performance under heavy load.","acceptance_criteria":"When file watcher is under heavy load (100+ files written quickly), verify that pending timers don't accumulate beyond a reasonable threshold (max ~20-30 pending).","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T18:08:31.280075-08:00","updated_at":"2025-12-02T20:55:59.383112-08:00","closed_at":"2025-12-02T20:55:59.383112-08:00"}
{"id":"ef-8o2","title":"Extract shared HTTP/API client layer (efrit-api.el)","description":"Both efrit-chat-api.el and efrit-executor.el duplicate HTTP request building logic:\n- JSON encoding with Unicode escaping\n- Header construction (x-api-key, anthropic-version, content-type)\n- url-retrieve / url-retrieve-synchronously calls\n- Response parsing\n\nCreate efrit-api.el (or extend efrit-common.el) with:\n```elisp\n(defun efrit-api-build-headers (api-key) ...)\n(defun efrit-api-request-async (request-data callback) ...)\n(defun efrit-api-request-sync (request-data \u0026optional timeout) ...)\n```\n\nAlso unify header customization:\n- efrit-custom-headers and efrit-excluded-headers are chat-only but should be shared\n\nFiles affected:\n- lisp/core/efrit-chat-api.el (efrit--build-headers, ~200 lines of HTTP code)\n- lisp/core/efrit-executor.el (efrit-executor--api-request, efrit-executor--sync-api-call)","acceptance_criteria":"1. Single efrit-api-request-async function used by both chat and executor\n2. Header customization (custom/excluded headers) works consistently in both modes\n3. No duplicated JSON encoding or Unicode escaping logic","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.180206-08:00","updated_at":"2025-12-02T22:37:37.783347-08:00","closed_at":"2025-12-02T22:37:37.783347-08:00"}
{"id":"ef-byp","title":"Standardize tool naming between chat and do modes","description":"Inconsistent tool names across modes:\n- buffer_create (do schema) vs create_buffer (chat-tool handling)\n- Chat-only tools (create_buffer, edit_buffer, read_buffer, buffer_info, get_context) not in efrit-do-schema.el\n\nThis makes it hard to reason about \"the set of tools Efrit supports\".\n\nOptions:\n1. Decide on canonical names (prefer existing do schema: buffer_create, buffer_read, etc.)\n2. Add aliases in dispatcher (accept both \"create_buffer\" and \"buffer_create\")\n3. Long-term: derive chat and do schemas from same source\n\nStart with option 2 - add aliases without breaking existing code.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (dispatch table)\n- lisp/core/efrit-do-schema.el (add any missing tools)\n- lisp/core/efrit-chat-api.el (tool handling)","acceptance_criteria":"1. Documented canonical tool naming convention\n2. Both old and new names work via aliases\n3. No behavior change for existing users","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-02T21:58:07.25901-08:00","updated_at":"2025-12-02T21:58:07.25901-08:00"}
{"id":"ef-dbe","title":"Add SECURITY.md documenting trust model and Elisp execution risks","description":"Efrit is effectively \"remote code execution in Emacs\" but this isn't clearly documented.\n\nNeed a SECURITY.md (or README section) covering:\n1. Trust model - Efrit trusts Claude/Anthropic with running arbitrary Elisp\n2. What context is sent (user-login-name, home-directory, recent-files, etc.)\n3. Recommended practices (don't run as root, audit shell whitelist, etc.)\n4. Shell command security and remote access implications","acceptance_criteria":"1. SECURITY.md exists with comprehensive coverage\n2. README links to it prominently","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:47:45.039105-08:00","updated_at":"2025-12-02T22:07:14.686839-08:00","closed_at":"2025-12-02T22:07:14.686839-08:00"}
{"id":"ef-dcm","title":"Accept cwd parameter in MCP server beads_command tool","description":"The beads_command tool in mcp/src/server.ts should accept an optional cwd parameter to specify the working directory for bd commands.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:08:47.210928-08:00","updated_at":"2025-12-02T21:37:50.101945-08:00","closed_at":"2025-12-02T21:37:50.101945-08:00"}
{"id":"ef-e3b","title":"Progress buffer appears automatically in efrit-do async - verify this is working","description":"User requirement: The efrit-do working buffer (progress buffer) should automatically appear when efrit-do starts asynchronous execution.\n\nCurrent code shows:\n- efrit-do-async-show-progress-buffer is set to t\n- efrit-do-async-loop is called with show-progress enabled\n- But this hasn't been manually tested\n\nNeed to:\n1. Verify progress buffer auto-displays when running efrit-do (interactive test)\n2. Verify it can be hidden with efrit-do-silently\n3. Verify it can be shown manually with efrit-do-show-progress\n4. Check that window management works correctly (doesn't break existing layout)","acceptance_criteria":"1. Run efrit-do with a test command, verify progress buffer appears automatically without manual action\n2. Run efrit-do-silently, verify no progress buffer appears\n3. Run efrit-do-show-progress, verify it displays the progress buffer\n4. Verify Emacs window layout is reasonable (doesn't delete user's existing windows)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:35.397107-08:00","updated_at":"2025-12-02T20:52:55.560788-08:00","closed_at":"2025-12-02T20:52:55.560788-08:00"}
{"id":"ef-h8e","title":"Extract TODO item struct to efrit-todo.el from efrit-do.el","description":"efrit-tools.el declares functions from efrit-do.el for TODO item access:\n- efrit-do-todo-item-status\n- efrit-do-todo-item-priority\n- efrit-do-todo-item-content\n- efrit-do-todo-item-id\n\nThis inverts the dependency: core tools should not depend on workflow-specific code.\n\nCreate efrit-todo.el containing:\n- efrit-do-todo-item struct definition (cl-defstruct)\n- Accessor functions\n- efrit-do--current-todos variable\n- TODO-related helper functions\n\nThen:\n- efrit-do.el requires efrit-todo.el for TODO state management\n- efrit-tools.el requires efrit-todo.el instead of declaring efrit-do functions\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (lines 333-414 - TODO management)\n- lisp/core/efrit-tools.el (lines 61-64 declarations, 826-854 format functions)","acceptance_criteria":"1. efrit-todo.el with struct definition and state management\n2. efrit-tools.el requires efrit-todo.el (no efrit-do declarations)\n3. Cleaner module layering: efrit-todo → efrit-tools → efrit-do","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.22065-08:00","updated_at":"2025-12-02T23:03:24.367937-08:00","closed_at":"2025-12-02T23:03:24.367937-08:00"}
{"id":"ef-i2q","title":"Document when to use efrit-chat vs efrit-do vs efrit-agent","description":"Users (especially those from Claude Code) will be confused about which mode to use:\n\n1. efrit-chat - Multi-turn conversation, buffer-centric tools only\n2. efrit-do - Agentic command execution, full project/file tool suite\n3. efrit-agent - Structured session view for efrit-do\n\nREADME currently doesn't clearly explain:\n- Chat has much smaller tool surface than efrit-do\n- Project-wide refactor/fix workflows should use efrit-do\n- The agent buffer exists and how to use it\n\nThe efrit-agent buffer is one of the nicest parts of Efrit but is never mentioned in README!","acceptance_criteria":"1. README has clear \"When to use\" section explaining each mode\n2. efrit-agent mentioned in Features and Usage sections\n3. Help text improved to guide users to correct mode","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T21:47:45.009469-08:00","updated_at":"2025-12-02T22:05:36.308592-08:00","closed_at":"2025-12-02T22:05:36.308592-08:00"}
{"id":"ef-ibi","title":"Remove backward compatibility cruft from codebase","description":"This is a new codebase - we don't need backward compatibility with older versions.\n\nReview and remove:\n- define-obsolete-function-alias declarations\n- define-obsolete-variable-alias declarations\n- defalias wrappers that exist only for compatibility\n- Comments mentioning deprecated, legacy, backward compatibility\n- Any bridge or adapter code between old/new APIs\n- Variables marked as deprecated (e.g., efrit-api-url in efrit-common.el)\n\nKnown locations to check:\n- lisp/core/efrit-api.el: backward compatibility section at end\n- lisp/core/efrit-common.el: efrit-api-url deprecated variable, efrit-common-truncate-string obsolete alias\n- lisp/core/efrit-chat-api.el: defalias wrappers for efrit--build-headers, efrit--build-tool-result\n\nAfter cleanup:\n- Rename functions to their canonical names (no aliases needed)\n- Remove deprecated variables entirely\n- Update all callers to use the new names directly","acceptance_criteria":"1. No define-obsolete-*-alias in codebase\n2. No defalias used for compatibility (only for genuine semantic aliases)\n3. No deprecated/legacy variables or comments\n4. All functions use their canonical names\n5. make compile passes with no warnings","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-12-02T22:39:04.115703-08:00","updated_at":"2025-12-02T22:40:55.860384-08:00","closed_at":"2025-12-02T22:40:55.860384-08:00"}
{"id":"ef-mch","title":"Elisp eval is unbounded - can hang Emacs with no timeout","description":"efrit-tools-eval-sexp has no timeout or sandbox around Elisp evaluation. A single misgenerated form (infinite while loop, tight recursion, blocking I/O) can freeze Emacs until user hits C-g.\n\nThis is acceptable for advanced users who understand the risk, but:\n1. README doesn't prominently document this risk\n2. No opt-in timeout mechanism exists\n3. No mention of efrit-tools-sexp-evaluation-enabled config option\n\nSUGGESTED FIX:\nAdd optional timeout wrapping with efrit-tools-eval-timeout custom variable.","acceptance_criteria":"1. Configurable timeout for eval_sexp (default on, reasonable value like 30s)\n2. Document the risk in README's security section\n3. Document efrit-tools-sexp-evaluation-enabled as a safety switch","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:47:44.999174-08:00","updated_at":"2025-12-02T22:30:52.445339-08:00","closed_at":"2025-12-02T22:30:52.445339-08:00"}
{"id":"ef-phj","title":"Use shell-quote-argument in efrit-tool-beads.el for safer shell command construction","description":"Security fix: The beads tool functions should use shell-quote-argument when constructing shell commands to prevent injection vulnerabilities.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:08:47.089095-08:00","updated_at":"2025-12-02T21:09:43.087879-08:00","closed_at":"2025-12-02T21:09:43.087879-08:00"}
{"id":"ef-ri7","title":"Extract prompt strings to dedicated *-prompt.el modules","description":"Large prompt strings bloat logic files:\n\n1. efrit-do.el contains prompt-building functions:\n   - efrit-do--command-examples\n   - efrit-do--command-formatting-tools  \n   - efrit-do--command-common-tasks\n   - efrit-do--command-project-workflow\n   - efrit-do--session-protocol-instructions\n\n2. efrit-tools.el has a massive efrit-tools-system-prompt (~200 lines of string concatenation)\n\nCreate:\n- lisp/core/efrit-do-prompt.el - move all efrit-do--command-* functions\n- lisp/core/efrit-tools-prompt.el - move efrit-tools-system-prompt\n\nThis is low-risk cut/paste that immediately reduces file sizes.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (currently ~600 lines omitted in analysis suggests more prompt code)\n- lisp/core/efrit-tools.el (lines 590-789 are system prompt)","acceptance_criteria":"1. efrit-do-prompt.el contains all prompt-building functions\n2. efrit-tools-prompt.el contains efrit-tools-system-prompt\n3. Original files reduced by combined ~400 lines\n4. All tests/compilation still pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.209916-08:00","updated_at":"2025-12-02T22:14:46.324925-08:00","closed_at":"2025-12-02T22:14:46.324925-08:00"}
{"id":"ef-t57","title":"Chat mode lacks circuit breaker - only bounded by efrit-max-turns","description":"efrit-do has robust circuit breaker with max-tool-calls-per-session and error-loop detection.\n\nefrit-chat only has efrit-max-turns (default 2) and retry-on-error logic.\n\nIf chat tools keep failing, the model can burn tokens retrying with no per-tool loop detection.\n\nLower priority since max-turns provides some protection.","acceptance_criteria":"Either: add lightweight tool-call tracking to chat, OR document that only efrit-do has circuit breaker semantics","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-02T21:47:45.048556-08:00","updated_at":"2025-12-02T21:47:45.048556-08:00"}
{"id":"ef-uso","title":"Check for resource leaks in async execution loop","description":"User requirement: No resource leaks before release.\n\nAreas to audit:\n1. Buffer cleanup - are temporary buffers closed after sessions end?\n2. Timer cleanup - are all timers canceled when sessions end?\n3. Hash table cleanup - are session loops removed from tracking?\n4. HTTP connections - are URL requests properly closed?\n5. File handles - are any files left open after operations?\n\nCurrent code analysis shows:\n- efrit-do-async-loop.el properly cleans up via remhash (line 350)\n- Progress buffers may accumulate if many sessions run\n- One-shot timers in callbacks aren't tracked (efrit-do.el:1188, efrit-remote-queue.el:526)\n- Need to verify real cleanup under heavy load\n\nTesting needed:\n1. Run 10+ sequential efrit-do commands, check buffer count\n2. Monitor timer objects with (timer-list)\n3. Check for orphaned processes\n4. Stress test with concurrent commands and queueing\n5. Check memory growth over time","acceptance_criteria":"After running 10+ commands in quick succession, verify: no accumulation of buffers, no orphaned timers, no memory growth, no file descriptor leaks","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T18:08:50.308795-08:00","updated_at":"2025-12-02T20:56:50.945684-08:00","closed_at":"2025-12-02T20:56:50.945684-08:00"}
{"id":"ef-whm","title":"efrit-chat-api.el: split API communication from tool handling","description":"efrit-chat-api.el (1077 lines) mixes:\n1. HTTP/API request building and response parsing\n2. Classic chat mode message handling\n3. Streamlined mode implementation\n4. Tool call extraction and execution\n5. UI updates (efrit--display-message, etc.)\n\nAfter extracting shared API client (ef-xxx), consider further splitting:\n- efrit-chat-transport.el: HTTP layer (if not moved to efrit-api.el)\n- efrit-chat-classic.el: Classic multi-turn chat mode\n- efrit-chat-streamlined.el: Streamlined mode (~200 lines starting at line 664)\n\nThis is lower priority since the shared API extraction addresses the main duplication.\n\nFiles affected:\n- lisp/core/efrit-chat-api.el","acceptance_criteria":"1. Clear separation of concerns if split performed\n2. Each file under 400 lines\n3. Tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-02T21:58:07.267796-08:00","updated_at":"2025-12-02T21:58:07.267796-08:00"}
{"id":"ef-xmw","title":"CRITICAL: efrit-chat and efrit-do have very different tool sets - NOT feature parity","description":"CRITICAL ISSUE: efrit-chat only has 8 basic tools while efrit-do has 34 comprehensive tools.\n\nefrit-chat tools (hardcoded in efrit-chat-api.el lines 222-304):\n1. eval_sexp\n2. get_context\n3. resolve_path\n4. read_image\n5. create_buffer\n6. edit_buffer\n7. read_buffer\n8. buffer_info\n\nefrit-do tools (via efrit-do-schema.el):\n- All 8 chat tools PLUS\n- shell_exec\n- todo_write\n- session_complete\n- glob_files\n- request_user_input\n- confirm_action\n- checkpoint/restore\n- show_diff_preview\n- web_search\n- fetch_url\n- project_files\n- search_content\n- read_file\n- edit_file\n- create_file\n- file_info\n- vcs_status/diff/log/blame\n- elisp_docs\n- set_project_root\n- get_diagnostics\n- format_file\n- undo_edit\n- display_in_buffer\n- format_file_list\n- format_todo_list\n\nThis breaks the user requirement that efrit-chat should have access to all the same tools as efrit-do.\n\nBlocker for release until resolved.","acceptance_criteria":"efrit-chat must have access to all 34 tools available in efrit-do, OR the user must be clearly informed that efrit-chat is intentionally limited (not recommended for one-off tasks that need file operations)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T18:09:00.3812-08:00","updated_at":"2025-12-02T18:14:46.073883-08:00","closed_at":"2025-12-02T18:14:46.073883-08:00"}
{"id":"ef-xx4","title":"Shell security: ssh/scp/rsync allowed by default - document remote host risk","description":"efrit-do-allowed-shell-commands includes ssh, scp, and rsync by default.\n\nThis means Claude can connect to any host in user's SSH config, copy files to/from remote systems, and execute commands on remote systems.\n\nThe shell security section in README doesn't highlight this remote-host risk.\n\nOPTIONS:\nA) Remove ssh/scp/rsync from default whitelist\nB) Add prominent documentation warning\nC) Add separate remote access tool category","acceptance_criteria":"1. Either: ssh/scp/rsync removed from defaults, OR clear documentation about remote access implications\n2. Warning when using (\"*\") or disabling security","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T21:47:45.029476-08:00","updated_at":"2025-12-02T22:07:25.784341-08:00","closed_at":"2025-12-02T22:07:25.784341-08:00"}
{"id":"ef-zsd","title":"Add Beads MCP tool to Efrit","description":"Give Efrit access to beads CLI through MCP server. This allows Efrit to:\n- Check ready work (bd ready)\n- Create issues (bd create)\n- Update issue status (bd update)\n- Close issues (bd close)\n- List and query issues (bd list)\n- Inspect dependencies (bd show)\n\nShould be implemented as an MCP tool in the TypeScript/Node MCP server.","acceptance_criteria":"Efrit can execute beads commands through MCP and receive structured results. At minimum: bd ready, bd create, bd update, bd close, bd list","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T18:27:05.1739-08:00","updated_at":"2025-12-02T20:55:12.528625-08:00","closed_at":"2025-12-02T20:55:12.528625-08:00"}
