{"id":"ef-088","title":"Add tool call navigation commands (M-n/M-p, copy)","description":"Add convenience commands for navigating between tool calls and interacting with them.\n\nIMPLEMENTATION:\n1. efrit-agent-next-tool (M-n)\n   - Jump to next tool call in buffer\n   - Use next-single-property-change on 'efrit-id\n\n2. efrit-agent-previous-tool (M-p)\n   - Jump to previous tool call\n   - Use previous-single-property-change on 'efrit-id\n\n3. efrit-agent-copy-tool-output (w key)\n   - Copy the current tool's full output to kill ring\n   - Works on tool at point\n\n4. Update efrit-agent-mode-map with new bindings\n\n5. Update help text in efrit-agent-help\n\nFILES: lisp/interfaces/efrit-agent.el","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T20:14:23.255864-08:00","updated_at":"2025-12-03T20:20:23.890023-08:00","closed_at":"2025-12-03T20:20:23.890023-08:00","dependencies":[{"issue_id":"ef-088","depends_on_id":"ef-3at","type":"parent-child","created_at":"2025-12-03T20:14:36.790062-08:00","created_by":"daemon"}]}
{"id":"ef-0jt","title":"Expand/collapse all keybindings","description":"Add E keybinding to expand all tool results. Add C keybinding to collapse all. Update expansion state hash for all tools when used. These override Claude hints and display mode.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:50:39.955938-08:00","updated_at":"2025-12-03T18:33:55.597118-08:00","closed_at":"2025-12-03T18:33:55.597118-08:00","dependencies":[{"issue_id":"ef-0jt","depends_on_id":"ef-3i9","type":"blocks","created_at":"2025-12-03T17:50:53.773405-08:00","created_by":"daemon"}]}
{"id":"ef-0kr","title":"Redesign efrit interface: Replace command+progress model with interactive prompt loop","description":"","design":"Current UX model (fire-and-forget efrit-do):\n- User runs M-x efrit-do, types command once\n- Shows progress buffer with status\n- No way to ask follow-up questions or interact\n- Feels disconnected from what agent is doing\n\nTarget UX model (Amp/Claude Code style):\n- Single persistent \"Efrit Agent\" prompt buffer (REPL-like)\n- User types prompt at bottom \"\u003e \" cursor\n- Agent responses stream in above\n- Always ready for next prompt\n- IDE-like layout: prompt area at bottom, scrolling conversation/results above\n\nMerge architecture:\n- Unify efrit-chat, efrit-do, efrit-agent into single mode\n- Single well-designed buffer with regions:\n  * Top: Scrolling output/conversation area\n  * Middle: TODO/task list (fixed, refreshing)\n  * Bottom: Input prompt (single line or minibuffer-like)\n- Session persistence and history\n- Tool results display inline with results\n- Clear visual distinction between:\n  * User input\n  * Agent responses/reasoning\n  * Tool outputs\n  * Errors/warnings","acceptance_criteria":"1. Single efrit-agent buffer with prompt-loop UX\n2. Can type multiple prompts without restarting\n3. Agent can ask for clarification (prompt user for input)\n4. IDE-like layout with fixed regions\n5. Streaming output visible as agent works\n6. Session history preserved\n7. Tool results formatted inline with conversation","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-04T11:36:51.064597-08:00","updated_at":"2025-12-04T11:36:51.064597-08:00"}
{"id":"ef-0pd","title":"DRY up tool handler boilerplate with macro/helper","description":"Many handlers in efrit-do-handlers.el follow identical patterns:\n\n```elisp\n(defun efrit-do--handle-FOO (tool-input)\n  (require 'efrit-tool-foo)\n  (or (efrit-do--validate-hash-table tool-input \"foo\")\n      (efrit-do--validate-required tool-input \"foo\" \"field1\")\n      (let* ((args (efrit-do--extract-fields tool-input '(\"field1\" \"field2\")))\n             (result (efrit-tool-foo args)))\n        (efrit-do--format-tool-result result \"Foo Result\"))))\n```\n\nThis is repeated for ~20 tools: web_search, fetch_url, read_file, edit_file, create_file, vcs_*, etc.\n\nCreate a macro or helper:\n\n```elisp\n(defmacro efrit-define-simple-tool-handler\n    (fn-name tool-name required-fields field-specs underlying-fn label \u0026optional require-lib)\n  ...)\n```\n\nThen replace boilerplate handlers with one-liners.\n\nFile affected:\n- lisp/interfaces/efrit-do-handlers.el (reduce from 879 to ~500 lines)","acceptance_criteria":"1. Macro defined for simple tool handlers\n2. At least 15 handlers converted to macro usage\n3. Easier to add new tools - single line per simple tool\n4. Byte-compile warnings unchanged or improved","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.240879-08:00","updated_at":"2025-12-02T23:14:18.369197-08:00","closed_at":"2025-12-02T23:14:18.369197-08:00"}
{"id":"ef-0sa","title":"Agent buffer not automatically entering efrit-agent-mode","description":"When efrit-agent--get-buffer creates a new buffer, it doesn't automatically enter efrit-agent-mode. This means the buffer starts in fundamental-mode and lacks all the UI rendering, keybindings, and functionality provided by efrit-agent-mode.\n\nCurrent behavior: Buffer is created but doesn't have proper mode\nExpected behavior: Buffer should automatically enter efrit-agent-mode when created\n\nThis affects the user experience when invoking efrit-do/agentic mode - the agent buffer appears but without any of the special UI features like status display, task rendering, activity log, etc.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-03T17:26:00.180834-08:00","updated_at":"2025-12-03T17:26:36.265148-08:00","closed_at":"2025-12-03T17:26:36.265148-08:00"}
{"id":"ef-0v9","title":"Add loading spinner to efrit-chat buffer during API calls","description":"Add a visual spinner or loading indicator in the chat buffer when waiting for API responses. Users perceive the application as unresponsive during slow API calls.","acceptance_criteria":"- Spinner appears in chat buffer when API call starts\n- Spinner disappears when response arrives\n- Spinner provides visual feedback that system is working","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-03T10:45:19.32003-08:00","updated_at":"2025-12-03T10:47:18.445578-08:00","closed_at":"2025-12-03T10:47:18.445578-08:00"}
{"id":"ef-15l","title":"Unify retry \u0026 rate-limit configuration across modules","description":"Duplicate and mode-specific retry/limit knobs:\n\nChat mode:\n- efrit-max-retries\n- efrit-retry-on-errors\n\nDo mode:\n- efrit-do-max-retries\n- efrit-do-retry-on-errors\n\nTools:\n- efrit-tools-max-eval-per-session\n- efrit-tools-max-total-calls-per-session\n\nExecutor:\n- efrit-executor-max-continuations\n- efrit-executor-max-tool-calls\n- efrit-executor-session-timeout\n\nConsolidate in efrit-config.el (or new efrit-limits.el):\n- efrit-tool-max-retries (shared default: 3)\n- efrit-tool-retry-on-errors (shared default: t)\n- efrit-tool-max-calls-per-session (shared)\n- efrit-session-timeout (shared)\n\nHave each module use these shared values or bind local overrides.\n\nFiles affected:\n- lisp/core/efrit-config.el\n- lisp/core/efrit-chat-api.el\n- lisp/interfaces/efrit-do.el\n- lisp/core/efrit-tools.el\n- lisp/core/efrit-executor.el","acceptance_criteria":"1. Fewer total defcustom variables for limits/retries\n2. Consistent behavior between chat and do modes\n3. Single place to configure session safety limits","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.23098-08:00","updated_at":"2025-12-02T23:17:21.593022-08:00","closed_at":"2025-12-02T23:17:21.593022-08:00"}
{"id":"ef-1al","title":"Importance styling and icons","description":"Define faces for importance levels: normal (default), success (green), warning (yellow), error (red). Update tool summary icon based on importance. Apply face to summary line. Ensure error importance is visually prominent.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:50:35.617627-08:00","updated_at":"2025-12-03T18:14:03.344972-08:00","closed_at":"2025-12-03T18:14:03.344972-08:00","dependencies":[{"issue_id":"ef-1al","depends_on_id":"ef-inx","type":"blocks","created_at":"2025-12-03T17:50:53.651262-08:00","created_by":"daemon"}]}
{"id":"ef-1cf","title":"File content renderer with syntax highlighting","description":"Create efrit-agent--render-file-content for Read/Write tool results. Add syntax highlighting via font-lock based on file extension. Include line numbers. Make file path clickable to open file.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:22.690192-08:00","updated_at":"2025-12-03T17:50:01.944556-08:00","closed_at":"2025-12-03T17:50:01.944556-08:00","dependencies":[{"issue_id":"ef-1cf","depends_on_id":"ef-wpj","type":"blocks","created_at":"2025-12-03T17:42:54.796095-08:00","created_by":"daemon"}]}
{"id":"ef-1jo","title":"efrit-do fails with format error and missing tool execution function","description":"When executing `efrit-do` with command \"open the mayor dir in ~/ai\", the command fails with multiple errors:\n\n1. Format string error in logging: \"Format specifier doesn't match argument type\" - format call passes nil for %d iterations parameter\n\n2. Missing function: \"Symbol's function definition is void: efrit-do-async--execute-single-tool\" - indicates tool execution is not implemented or not exported\n\n3. API error from Claude: \"messages.1: `tool_use` ids were found without `tool_result` blocks immediately after\" - the tool_use block is not being properly followed by a tool_result block in the message continuation\n\nThis blocks basic efrit-do functionality.","acceptance_criteria":"- Format string error is fixed (handle nil iterations gracefully)\n- efrit-do-async--execute-single-tool function is implemented/exported\n- Tool execution flow properly constructs tool_result blocks for API continuations","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-03T10:51:58.269061-08:00","updated_at":"2025-12-03T10:54:47.735396-08:00","closed_at":"2025-12-03T10:54:47.735396-08:00"}
{"id":"ef-1lu","title":"Chat advertises full efrit-do tools but only implements 7 - returns \"Unknown tool\" errors","description":"CRITICAL FOR PRODUCTION:\n\nefrit-chat-api.el sends the full efrit-do tool schema to Claude:\n(\"tools\" . ,(efrit-do--get-current-tools-schema))\n\nBut the actual tool handlers only support 7 tools:\n1. eval_sexp\n2. get_context\n3. read_image\n4. create_buffer\n5. edit_buffer\n6. read_buffer\n7. buffer_info\n\nAll other tools (project_files, search_content, read_file, edit_file, create_file, vcs_*, checkpoints, etc.) will return \"Error: Unknown tool\" when Claude tries to use them.\n\nThis creates terrible UX where:\n1. Claude *believes* it can call 30+ tools in chat\n2. Most calls fail with confusing errors\n3. Users burn tokens on retries\n\nFIX OPTIONS:\nA) Delegate unknown tools to efrit-do--dispatch-tool (simple path)\nB) Restrict chat schema to only the 7 implemented tools (fast fix)\nC) Full unification of tool execution between chat and efrit-do","acceptance_criteria":"1. efrit-chat either supports all advertised tools OR only advertises tools it can execute\n2. No \"Unknown tool\" errors when using efrit-chat with tools in the schema","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-02T21:47:44.985623-08:00","updated_at":"2025-12-02T21:52:40.646183-08:00","closed_at":"2025-12-02T21:52:40.646183-08:00"}
{"id":"ef-1s7","title":"Verify efrit-chat has same tool access as efrit-do","description":"User requirement: efrit-chat should have access to all the same tools as efrit-do for quick one-off tasks.\n\nCurrent status:\n- efrit-do has 34 tools via efrit-do-schema.el\n- efrit-chat uses its own tool definitions (need to verify if same)\n- Need to confirm parity and identify any gaps\n\nKey questions:\n1. Does efrit-chat send the same tool schema to Claude?\n2. Are all tools like eval_sexp, shell_exec, todo_write available in chat?\n3. Any tools in efrit-do missing from efrit-chat?\n4. Any tools in efrit-chat missing from efrit-do (that shouldn't be)?","acceptance_criteria":"Document which tools are available in both systems, identify any tool gaps, and ensure feature parity for one-off tasks","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:40.938928-08:00","updated_at":"2025-12-02T18:14:55.124961-08:00","closed_at":"2025-12-02T18:14:55.124961-08:00"}
{"id":"ef-27n","title":"Agent input starts efrit-do session when no session active","description":"Modify `efrit-agent-input-send` to start a new efrit-do async session when the user presses RET in the agent buffer and no session is currently active.\n\nThis is the core REPL behavior: type a command at the `\u003e ` prompt, hit RET, and a session starts.\n\n## Acceptance Criteria\n1. With no active session, typing at `\u003e ` prompt and pressing RET starts a new session\n2. The session is identical to one started via `M-x efrit-do` (same behavior, same progress buffer)\n3. Agent buffer header-line changes from \"Idle\" to \"Working\"\n4. User message appears in conversation region with `\u003e ` prefix\n5. Claude responses stream into the conversation region above\n6. With an active session, input continues to work as before (guidance injection, question responses)\n7. `make compile` passes","design":"## What to Build\n\nExtend `efrit-agent-input-send` in `efrit-agent-input.el` to detect when no session is active and start a new one.\n\n## Implementation\n\nModify `efrit-agent-input-send` in `lisp/interfaces/efrit-agent-input.el`:\n\n```elisp\n(defun efrit-agent-input-send ()\n  \"Send the current input.\"\n  (interactive)\n  (let ((input (efrit-agent--get-input)))\n    (if (or (null input) (string-empty-p (string-trim input)))\n        (message \"Nothing to send\")\n      ;; Add to history and show in conversation\n      (efrit-agent--add-to-history input)\n      (efrit-agent--reset-history-navigation)\n      (efrit-agent--add-user-message input)\n      (efrit-agent--clear-input)\n      (goto-char efrit-agent--input-start)\n      \n      (let ((session (efrit-session-active)))\n        (cond\n         ;; Existing: respond or inject guidance to active session\n         (session\n          (if (efrit-session-waiting-for-user-p session)\n              (progn\n                (efrit-session-respond-to-question session input)\n                (setq efrit-agent--pending-question nil)\n                (efrit-agent-set-status 'working))\n            (efrit-session-add-message session 'user input)\n            (message \"Guidance injected to session\")))\n         \n         ;; NEW: start a new efrit-do session from this input\n         (t\n          (require 'efrit-do)\n          (let ((session (efrit-do--start-async-session input)))\n            ;; Attach this buffer's UI state to the new session\n            (setq efrit-agent--session-id (efrit-session-id session))\n            (setq efrit-agent--command input)\n            (setq efrit-agent--status 'working)\n            (setq efrit-agent--start-time (current-time))\n            ;; Initialize pending tools hash table\n            (setq efrit-agent--pending-tools (make-hash-table :test 'equal))\n            ;; Start elapsed timer if not running\n            (unless efrit-agent--elapsed-timer\n              (setq efrit-agent--elapsed-timer\n                    (run-at-time 1 1 #'efrit-agent--update-elapsed (current-buffer))))\n            (message \"Efrit: started session from agent buffer\"))))))))\n```\n\nAlso add a forward declaration near the top of the file:\n```elisp\n(declare-function efrit-do--start-async-session \"efrit-do\")\n```\n\n## Files to Modify\n- `lisp/interfaces/efrit-agent-input.el`\n\n## Verification Steps\n1. `M-x efrit-agent-open`\n2. Type a command at `\u003e ` prompt and press RET\n3. User message appears in conversation with `\u003e ` prefix\n4. Header-line changes to \"Working\" with elapsed time\n5. Progress buffer appears (same as efrit-do behavior)\n6. Claude responses stream into agent buffer above the input region\n7. After completion, header-line shows \"Complete\"\n8. With a session running, typing at prompt injects guidance (existing behavior preserved)\n9. `make compile` passes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-04T11:45:30.218949-08:00","updated_at":"2025-12-04T14:54:22.044096-08:00","closed_at":"2025-12-04T14:54:22.044096-08:00","dependencies":[{"issue_id":"ef-27n","depends_on_id":"ef-81q","type":"blocks","created_at":"2025-12-04T11:46:44.564413-08:00","created_by":"daemon"},{"issue_id":"ef-27n","depends_on_id":"ef-m1u","type":"blocks","created_at":"2025-12-04T11:46:44.571755-08:00","created_by":"daemon"}]}
{"id":"ef-2c1","title":"Unify tool_result building across chat and executor","description":"Tool result packaging is duplicated and inconsistent:\n\nefrit-chat-api.el:\n- efrit--build-tool-result (handles image results and text)\n\nefrit-executor.el:\n- efrit-executor--process-sync-content builds tool_result blocks ad-hoc\n- efrit-session-build-tool-result used in async path\n\nTools return different shapes:\n- Text strings with embedded markers ([SESSION-COMPLETE: ...], [WAITING-FOR-USER])\n- JSON-encoded payloads wrapped by efrit-do--format-tool-result\n- Image results as ((image . ...)) alists\n\nCreate efrit-tool-runtime.el (or add to efrit-common.el):\n```elisp\n(defun efrit-tool-build-result-block (tool-id result \u0026optional is-error)\n  \"Return a tool_result block suitable for Anthropic's messages API.\"\n  ...)\n```\n\nUse this single function in both chat and executor paths.\n\nFiles affected:\n- lisp/core/efrit-chat-api.el (efrit--build-tool-result)\n- lisp/core/efrit-executor.el (tool_result building)\n- lisp/core/efrit-session.el (efrit-session-build-tool-result)","acceptance_criteria":"1. Single tool_result building function used everywhere\n2. Consistent handling of image, text, and error results\n3. Session-control markers documented as part of tool contract","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.250076-08:00","updated_at":"2025-12-02T23:18:30.576138-08:00","closed_at":"2025-12-02T23:18:30.576138-08:00"}
{"id":"ef-2ia","title":"Standardize parameter naming (issue-id vs issue_id) in beads tools","description":"Inconsistent parameter naming between elisp (issue-id with hyphen) and JSON schemas (issue_id with underscore). Pick one convention and apply consistently.","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:08:47.150312-08:00","updated_at":"2025-12-02T21:34:00.327795-08:00","closed_at":"2025-12-02T21:34:00.327795-08:00"}
{"id":"ef-33f","title":"Call agent buffer on session start in async loop","description":"Wire the async loop to initialize the agent buffer when a session starts.\n\nCURRENT STATE:\n- efrit-agent--create-buffer and efrit-agent--show-buffer exist (private)\n- No public efrit-agent-start-session function exists yet\n\nIMPLEMENTATION (choose one approach):\n\nAPPROACH A (Recommended - Add public wrapper):\n1. In efrit-agent.el, add a new public function after line 917:\n   (defun efrit-agent-start-session (session-id command)\n     \"Start agent buffer for SESSION-ID with COMMAND.\"\n     (efrit-agent--create-buffer session-id command)\n     (efrit-agent--show-buffer)\n     (efrit-agent-set-status 'working))\n\n2. In efrit-do-async-loop.el, after line 78:\n   (require 'efrit-agent)\n   (efrit-agent-start-session session-id (efrit-session-command session))\n\nAPPROACH B (Use private functions directly):\n1. In efrit-do-async-loop.el around line 76-78, add:\n   (require 'efrit-agent)\n   (efrit-agent--create-buffer session-id (efrit-session-command session))\n   (efrit-agent--show-buffer)\n   (efrit-agent-set-status 'working)\n\nNOTE: You'll need to check if efrit-session has a 'command' accessor. Look at efrit-session.el for the struct definition. The command might be stored differently.\n\nFILES: lisp/interfaces/efrit-agent.el, lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run make compile, then M-x efrit-do with a simple command and verify the agent buffer appears.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:29:56.9455-08:00","updated_at":"2025-12-03T13:17:00.060373-08:00","closed_at":"2025-12-03T13:17:00.060373-08:00"}
{"id":"ef-3at","title":"Epic: Smart output management mode for agent buffer","description":"Transform the agent buffer from a linear log display into a sophisticated output management interface that shows collapsed summaries by default with intelligent expansion and type-specific rendering.\n\nThis is our primary ergonomic differentiator vs. web-based coding assistants. Modern tools (Amp, Claude Code) suppress output, show snippets, and provide expandable details. Emacs can do this *better* with proper mode design.\n\nGoals:\n- Keep agent buffer scannable and clean (collapsed by default)\n- Provide click-to-expand access to full tool output\n- Type-aware rendering (diffs, JSON, code, grep results, etc.)\n- Context-sensitive summaries (e.g., \"3 files modified, click to expand\")\n- Error emphasis (auto-expand failures, collapse successes)\n- Remember expansion state across re-renders\n- Support copy/navigation/interaction with rendered content\n\nThis epic is intentionally self-expanding. Start with design phase to create detailed implementation tasks.","design":"Core design: Use existing display_hint/render-type/importance plumbing as backbone.\n\nAPPROACH:\n1. Centralize tool-call rendering in one function (efrit-agent--render-tool-call)\n2. Define efrit-agent-tool-view struct for consistent tool state\n3. Fix auto-expand behavior (errors expand, successes collapse)\n4. Smart summaries from structured annotations (Claude provides, Emacs formats)\n5. Navigation/interaction commands (M-n/M-p, copy, clickable diffs)\n\nSUMMARY PRECEDENCE:\n1. Explicit summary from Claude's display_hint\n2. Formatted from structured annotations (:kind diff-summary, grep-summary, etc)\n3. Fallback to truncated result text\n\nDISPLAY MODES:\n- minimal: All collapsed, ignore hints\n- smart: Expand errors/warnings, collapse successes, respect auto_expand\n- verbose: All expanded\n\nCHILD TASKS:\n- ef-8of: Centralize rendering (HIGH - foundational)\n- ef-3x8: Fix auto-expand logic (HIGH - depends on ef-8of)\n- ef-958: Smart summaries from annotations (MEDIUM)\n- ef-088: Navigation commands (MEDIUM)\n- ef-9z1: Clickable diff headers (LOW)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-03T17:31:21.059164-08:00","updated_at":"2025-12-03T22:48:34.368611-08:00","closed_at":"2025-12-03T22:48:34.368611-08:00"}
{"id":"ef-3i9","title":"Display mode toggle (minimal/smart/verbose)","description":"Add efrit-agent-display-mode custom variable. Add M keybinding to cycle modes. Show current mode in header-line. minimal=ignore auto_expand (all collapsed), smart=respect auto_expand hints, verbose=ignore auto_expand (all expanded).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:50:36.662745-08:00","updated_at":"2025-12-03T18:17:05.865347-08:00","closed_at":"2025-12-03T18:17:05.865347-08:00","dependencies":[{"issue_id":"ef-3i9","depends_on_id":"ef-42x","type":"blocks","created_at":"2025-12-03T17:50:53.691778-08:00","created_by":"daemon"}]}
{"id":"ef-3pw","title":"Verify error handling and recovery in efrit-do async","description":"User requirement: Error handling must be solid for prime-time release.\n\nAreas to test:\n1. API errors (timeout, rate limit, auth failure) - should not crash, should show clear error\n2. Tool execution errors (bad elisp syntax, command not found) - should be caught and reported\n3. Circuit breaker trips - should show reason and allow recovery\n4. Session interruption (C-g) - should cleanup gracefully\n5. Recovery from errors - can Claude recover or does session need restart?\n\nCurrent implementation:\n- efrit-do--extract-error-info exists for error detection\n- efrit-do--build-error-context exists for context\n- Circuit breaker configured with limits\n- But integration testing needed\n\nTesting needed:\n1. Test bad elisp: (eval_sexp \"invalid lisp\")\n2. Test missing command: (shell_exec \"nonexistent_command\")\n3. Test timeout behavior\n4. Test session interruption\n5. Test recovery from transient errors","acceptance_criteria":"All error scenarios handled gracefully without crashing Emacs. Errors should be clearly displayed in progress buffer. Session should be recoverable or cleanly terminated.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:45.578341-08:00","updated_at":"2025-12-02T20:53:34.563982-08:00","closed_at":"2025-12-02T20:53:34.563982-08:00"}
{"id":"ef-3x8","title":"Fix auto-expand logic for error emphasis","description":"The epic wants errors highlighted and auto-expanded, successes collapsed. Currently:\n- efrit-agent--update-tool-result auto-expands short, successful results (wrong)\n- Doesn't explicitly favor expanding errors\n\nIMPLEMENTATION:\n1. Change auto-expand logic in efrit-agent--update-tool-result:\n   - Errors always auto-expand in smart mode\n   - Successes collapse unless very short\n\n2. Standardize importance-based expansion in efrit-agent--apply-display-hint:\n   - importance 'error → auto-expand true (unless user overrides)\n   - importance 'warning → auto-expand true  \n   - importance 'success/normal → collapse unless auto_expand hint is true\n\n3. Ensure display-mode behavior:\n   - minimal: always collapsed (ignores auto-expand)\n   - smart: respects error/warning auto-expand, collapses successes\n   - verbose: always expanded\n\nDEPENDENCIES: Requires centralized tool-view rendering to take effect.\n\nFILES: lisp/interfaces/efrit-agent-tools.el","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T20:14:23.233426-08:00","updated_at":"2025-12-03T20:19:02.911972-08:00","closed_at":"2025-12-03T20:19:02.911972-08:00","dependencies":[{"issue_id":"ef-3x8","depends_on_id":"ef-8of","type":"blocks","created_at":"2025-12-03T20:14:36.735455-08:00","created_by":"daemon"},{"issue_id":"ef-3x8","depends_on_id":"ef-3at","type":"parent-child","created_at":"2025-12-03T20:14:36.784468-08:00","created_by":"daemon"}]}
{"id":"ef-42x","title":"Tool result placeholder and hint application","description":"Show placeholder 'ToolName...' while tool executes. When DisplayHint arrives, update the tool display with the provided summary. If no hint arrives, use minimal default (truncated result text). Store hint data in text properties for later expansion.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:50:32.033848-08:00","updated_at":"2025-12-03T18:10:14.871276-08:00","closed_at":"2025-12-03T18:10:14.871276-08:00","dependencies":[{"issue_id":"ef-42x","depends_on_id":"ef-inx","type":"blocks","created_at":"2025-12-03T17:50:52.417531-08:00","created_by":"daemon"}]}
{"id":"ef-46k","title":"Stream Claude text content to agent buffer","description":"Stream Claude's text responses to the agent buffer for real-time display.\n\nCURRENT STATE:\n- efrit-agent-stream-content and efrit-agent-stream-end exist and work\n- efrit-do-async--on-api-response (line 154) receives API responses\n- Content is a VECTOR of content blocks, each with :type field\n\nIMPLEMENTATION:\n1. In efrit-do-async--on-api-response (line 154-181), after extracting content:\n\n2. Iterate through content blocks and stream text:\n   (dotimes (i (length content))\n     (let ((item (aref content i)))\n       (when (equal (gethash \"type\" item) \"text\")\n         (efrit-agent-stream-content (gethash \"text\" item)))))\n\n3. After the content loop, end the stream:\n   (efrit-agent-stream-end)\n\n4. Add (require 'efrit-agent) at top of file if not already present\n\nIMPORTANT DETAILS:\n- Content blocks are hash tables with \"type\" and \"text\" keys (string keys, not keywords)\n- Use gethash, not plist-get\n- The streaming functions handle buffer existence checks internally\n- Call stream-end after ALL text blocks are processed, not after each one\n\nEXISTING CODE CONTEXT (line 165-167):\n  (when content\n    (efrit-progress-insert-event session-id 'message\n      `((:text . ,(format \"%S\" content)) (:role . \"assistant\"))))\n\nInsert agent buffer calls alongside (not replacing) progress buffer calls.\n\nFILES: lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run efrit-do and verify Claude's text appears in agent buffer as it streams.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:30:06.066463-08:00","updated_at":"2025-12-03T13:18:00.332136-08:00","closed_at":"2025-12-03T13:18:00.332136-08:00","dependencies":[{"issue_id":"ef-46k","depends_on_id":"ef-33f","type":"blocks","created_at":"2025-12-03T12:31:29.223645-08:00","created_by":"daemon"}]}
{"id":"ef-4iw","title":"Show tool start and result in agent buffer","description":"Display tool executions in the agent buffer with start/result updates.\n\nCURRENT STATE:\n- efrit-agent-show-tool-start returns a tool-id (string)\n- efrit-agent-show-tool-result takes tool-id, result, success-p, elapsed\n- Tool execution happens in efrit-do-async--execute-tools (line 183-255)\n\nIMPLEMENTATION:\n1. In efrit-do-async--execute-tools, find the loop that processes tools (line 196)\n\n2. BEFORE tool execution (around line 213), add:\n   (let ((agent-tool-id (efrit-agent-show-tool-start tool-name input))\n         (tool-start-time (current-time)))\n     ;; existing tool execution code here\n     (let* ((tool-result (efrit-do-async--execute-single-tool ...))\n            ...existing code...\n            (elapsed-secs (float-time (time-subtract (current-time) tool-start-time))))\n       ;; AFTER tool completes, add:\n       (efrit-agent-show-tool-result agent-tool-id tool-result (not is-error) elapsed-secs)\n       ;; rest of existing code\n       ))\n\n3. The key variables available in the loop:\n   - tool-name: string like \"Read\" or \"Bash\"\n   - input: hash table of tool input parameters\n   - tool-result: string result from tool execution\n   - is-error: boolean (t if result starts with \"Error \")\n\n4. Wrap the tool execution in timing code to capture elapsed time\n\nEXISTING CODE PATTERN (lines 208-224):\n  ;; Fire progress event\n  (efrit-progress-insert-event session-id 'tool_started ...)\n  ;; Execute tool\n  (let* ((tool-result (efrit-do-async--execute-single-tool ...)))\n    ;; Fire result event  \n    (efrit-progress-insert-event session-id 'tool_result ...))\n\nMirror this pattern for agent buffer calls.\n\nFILES: lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run efrit-do with a command that uses tools, verify tools appear in agent buffer with timing.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:33:14.72815-08:00","updated_at":"2025-12-03T13:19:09.89796-08:00","closed_at":"2025-12-03T13:19:09.89796-08:00","dependencies":[{"issue_id":"ef-4iw","depends_on_id":"ef-33f","type":"blocks","created_at":"2025-12-03T12:33:22.061496-08:00","created_by":"daemon"}]}
{"id":"ef-4z6","title":"Extract tool dispatch runtime from efrit-do.el to efrit-do-dispatch.el","description":"efrit-do.el (1628 lines) mixes too many concerns:\n- User commands and customization\n- Tool dispatch table and runtime\n- Prompt construction\n- Context and TODO management\n\nefrit-chat-api.el and efrit-executor.el reach into efrit-do for tool execution, creating tight coupling and potential circular dependencies.\n\nExtract to efrit-do-dispatch.el:\n- efrit-do--tool-dispatch-table\n- efrit-do--dispatch-tool\n- efrit-do--execute-tool\n- Pure helpers used only by these (sanitization, error extraction)\n\nThen efrit-chat-api.el and efrit-executor.el can require efrit-do-dispatch instead of efrit-do.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (extract ~200 lines)\n- lisp/core/efrit-chat-api.el (change declare-function)\n- lisp/core/efrit-executor.el (change require)","acceptance_criteria":"1. New efrit-do-dispatch.el with tool dispatch table and execution\n2. efrit-do.el reduced to user-facing commands and state management\n3. efrit-chat-api.el requires efrit-do-dispatch not efrit-do\n4. No circular dependency warnings from byte-compile","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.196113-08:00","updated_at":"2025-12-02T22:47:35.926289-08:00","closed_at":"2025-12-02T22:47:35.926289-08:00"}
{"id":"ef-574","title":"Update README: version mismatch and incomplete tool table","description":"README is out of date:\n\n1. Version shows 0.4.0, code is at 0.4.1\n2. Advertises \"15+ tools\" but efrit-do-schema.el defines ~34 tools\n3. Missing tool categories: todo_write, get_diagnostics, beads_*, checkpoint/restore, show_diff_preview, read_image, format_file, undo_edit","acceptance_criteria":"1. Version updated to 0.4.1 everywhere\n2. Tool table expanded to show all major categories","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:47:45.019345-08:00","updated_at":"2025-12-02T22:06:24.445166-08:00","closed_at":"2025-12-02T22:06:24.445166-08:00"}
{"id":"ef-5oc","title":"Expand/collapse all commands","description":"Add E keybinding to expand all tool results. Add C keybinding to collapse all tool results. Both should set user-set flag on all items to prevent auto-expansion from overriding.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:29.145873-08:00","updated_at":"2025-12-03T17:50:01.946845-08:00","closed_at":"2025-12-03T17:50:01.946845-08:00","dependencies":[{"issue_id":"ef-5oc","depends_on_id":"ef-y30","type":"blocks","created_at":"2025-12-03T17:42:56.381255-08:00","created_by":"daemon"}]}
{"id":"ef-5pm","title":"System prompt additions for DisplayHint","description":"Add DisplayHint usage instructions to efrit-tools system prompt. Document: contextual summaries, render_type options, when to use auto_expand, importance levels. Include examples of good DisplayHint calls for common tools (Read, Edit, Bash, Grep).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:50:33.13575-08:00","updated_at":"2025-12-03T18:10:59.435747-08:00","closed_at":"2025-12-03T18:10:59.435747-08:00","dependencies":[{"issue_id":"ef-5pm","depends_on_id":"ef-inx","type":"blocks","created_at":"2025-12-03T17:50:52.460333-08:00","created_by":"daemon"}]}
{"id":"ef-5t5","title":"Add Claude Code migration guide for Emacs users","description":"For users coming from Claude Code, there's no guide mapping concepts:\n\nClaude Code → Efrit equivalent:\n- Chat sidebar → efrit-chat (limited) or efrit-do (full)\n- Project tools → efrit-do tools (not in chat currently)\n- Diff preview → show_diff_preview tool\n- Agent view → efrit-agent buffer\n- Progress view → Efrit Progress buffer\n- AI-to-AI → Remote queue (MCP)\n\nShould also note what's not yet available.","acceptance_criteria":"Documentation exists mapping Claude Code concepts to Efrit equivalents","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-02T21:47:45.05794-08:00","updated_at":"2025-12-02T23:43:23.020445-08:00","closed_at":"2025-12-02T23:43:23.020445-08:00"}
{"id":"ef-6eh","title":"Persistent user expansion state","description":"Track user-toggled expansion in efrit-agent--expansion-state hash table. When user presses RET to toggle, their preference overrides Claude's auto_expand hint and display mode setting. Preserve state across buffer updates.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:50:38.207999-08:00","updated_at":"2025-12-03T18:32:51.972046-08:00","closed_at":"2025-12-03T18:32:51.972046-08:00","dependencies":[{"issue_id":"ef-6eh","depends_on_id":"ef-3i9","type":"blocks","created_at":"2025-12-03T17:50:53.730534-08:00","created_by":"daemon"}]}
{"id":"ef-6v1","title":"Shell output renderer with ANSI support","description":"Create efrit-agent--render-shell for Bash tool results. Convert ANSI color codes to Emacs faces. Echo command at top of output. Style exit code prominently. Show stderr in warning face.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:26.669765-08:00","updated_at":"2025-12-03T17:50:01.94593-08:00","closed_at":"2025-12-03T17:50:01.94593-08:00","dependencies":[{"issue_id":"ef-6v1","depends_on_id":"ef-wpj","type":"blocks","created_at":"2025-12-03T17:42:54.916754-08:00","created_by":"daemon"}]}
{"id":"ef-7cb","title":"Add multi-session support to agent buffer","description":"Support multiple concurrent sessions with queue display and session switching.\n\nIMPLEMENTATION:\n1. Track multiple session-ids in efrit-agent-core.el\n2. Add session selector UI (maybe in header-line or sidebar)\n3. Queue display showing pending/running sessions\n4. Keybindings to switch between sessions\n5. Each session gets its own conversation history\n\nNOTE: This is backlog priority - single session works fine for most use cases.\n\nFILES: lisp/interfaces/efrit-agent-core.el, lisp/interfaces/efrit-agent.el","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-03T12:31:17.056471-08:00","updated_at":"2025-12-03T12:31:17.056471-08:00","dependencies":[{"issue_id":"ef-7cb","depends_on_id":"ef-zq8","type":"blocks","created_at":"2025-12-03T12:31:46.566362-08:00","created_by":"daemon"}]}
{"id":"ef-81q","title":"Add efrit-agent-open command for idle agent buffer","description":"Create a public command to open or switch to the *efrit-agent* buffer in idle mode, providing a persistent prompt buffer that can be used without an active session.\n\nThis is the foundational task for the new REPL-style UX.\n\n## Acceptance Criteria\n1. `M-x efrit-agent-open` opens `*efrit-agent*` buffer at bottom\n2. Buffer is in `efrit-agent-mode`\n3. Header-line shows \"Idle\" status when no session active\n4. Conversation region is read-only\n5. Input region is editable with `\u003e ` prompt\n6. `efrit-agent-input-mode` activates when point enters input region\n7. No errors when buffer is opened without an active session\n8. Re-running command when buffer exists switches to it without errors\n9. `make compile` passes","design":"## What to Build\n\nA new command `efrit-agent-open` in `lisp/interfaces/efrit-agent.el` that:\n1. Gets or creates the `*efrit-agent*` buffer\n2. Initializes `efrit-agent-mode` if not already active\n3. Sets up conversation/input regions if needed\n4. Sets status to 'idle when no session exists\n5. Displays buffer at bottom and moves point to input region\n\n## Implementation\n\nAdd this function to `efrit-agent.el`:\n\n```elisp\n;;;###autoload\n(defun efrit-agent-open ()\n  \"Open or switch to the Efrit agent buffer in idle mode.\nProvides a persistent prompt buffer for interacting with Efrit.\nType at the \u003e prompt to start a session (once Task 2 is done).\"\n  (interactive)\n  (let ((buffer (efrit-agent--get-buffer)))\n    (with-current-buffer buffer\n      ;; Initialize mode if not already done\n      (unless (derived-mode-p 'efrit-agent-mode)\n        (efrit-agent-mode))\n      ;; Initialize regions if not set up\n      (unless (and efrit-agent--conversation-end\n                   (marker-position efrit-agent--conversation-end))\n        (efrit-agent--init-regions)\n        (efrit-agent--setup-regions))\n      ;; Set idle state if no active session\n      (unless efrit-agent--session-id\n        (setq efrit-agent--status 'idle)\n        (setq efrit-agent--start-time nil)))\n    ;; Display and focus\n    (display-buffer buffer '(display-buffer-at-bottom (window-height . 15)))\n    (select-window (get-buffer-window buffer))\n    (goto-char (point-max))))\n```\n\n## Files to Modify\n- `lisp/interfaces/efrit-agent.el` - Add the new command\n\n## Verification Steps\n1. Run `M-x efrit-agent-open`\n2. Verify buffer `*efrit-agent*` opens at bottom\n3. Header-line shows \"○ Idle\"\n4. Conversation region (above separator) is read-only\n5. Input region (after `\u003e `) is editable\n6. Moving into input region enables `efrit-agent-input-mode` (check mode-line lighter)\n7. No errors when typing in input region with no session\n8. `make compile` passes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-04T11:44:47.287095-08:00","updated_at":"2025-12-04T14:53:09.767908-08:00","closed_at":"2025-12-04T14:53:09.767908-08:00"}
{"id":"ef-89z","title":"Agentic buffer interface for Efrit","description":"Wire the existing efrit-agent.el buffer implementation into efrit-do-async-loop.el to make it the primary display surface. The agent buffer infrastructure is ~80% complete - it just needs integration with the async execution loop. See docs/ef-9sy-agentic-buffer-plan.md for full analysis.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-03T12:29:39.04643-08:00","updated_at":"2025-12-03T12:32:41.077436-08:00","closed_at":"2025-12-03T12:32:41.077436-08:00"}
{"id":"ef-8o0","title":"Potential timer leak in file watcher callbacks (efrit-remote-queue.el)","description":"In efrit-remote-queue.el line 526, each file system event creates a fire-and-forget timer with run-at-time. Under heavy file I/O or rapid file writes, this could accumulate timer objects that are never tracked or explicitly canceled.\n\nThe timer pattern:\n```\n(run-at-time 0.1 nil #'efrit-remote-queue--process-file file-path)\n```\n\nThis is a one-shot timer (interval=nil), but:\n1. Not tracked in any hash table or variable\n2. Called from a file watcher callback that fires on every file event\n3. Could accumulate hundreds of timers if files are written rapidly\n\nPotential solutions:\n1. Add a debounce mechanism to prevent multiple timers for the same file\n2. Use a timer tracking hash table like async-loop uses\n3. Add a maximum pending timers guard\n\nNote: Low risk since each timer is one-shot, but could affect performance under heavy load.","acceptance_criteria":"When file watcher is under heavy load (100+ files written quickly), verify that pending timers don't accumulate beyond a reasonable threshold (max ~20-30 pending).","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T18:08:31.280075-08:00","updated_at":"2025-12-02T20:55:59.383112-08:00","closed_at":"2025-12-02T20:55:59.383112-08:00"}
{"id":"ef-8o2","title":"Extract shared HTTP/API client layer (efrit-api.el)","description":"Both efrit-chat-api.el and efrit-executor.el duplicate HTTP request building logic:\n- JSON encoding with Unicode escaping\n- Header construction (x-api-key, anthropic-version, content-type)\n- url-retrieve / url-retrieve-synchronously calls\n- Response parsing\n\nCreate efrit-api.el (or extend efrit-common.el) with:\n```elisp\n(defun efrit-api-build-headers (api-key) ...)\n(defun efrit-api-request-async (request-data callback) ...)\n(defun efrit-api-request-sync (request-data \u0026optional timeout) ...)\n```\n\nAlso unify header customization:\n- efrit-custom-headers and efrit-excluded-headers are chat-only but should be shared\n\nFiles affected:\n- lisp/core/efrit-chat-api.el (efrit--build-headers, ~200 lines of HTTP code)\n- lisp/core/efrit-executor.el (efrit-executor--api-request, efrit-executor--sync-api-call)","acceptance_criteria":"1. Single efrit-api-request-async function used by both chat and executor\n2. Header customization (custom/excluded headers) works consistently in both modes\n3. No duplicated JSON encoding or Unicode escaping logic","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.180206-08:00","updated_at":"2025-12-02T22:37:37.783347-08:00","closed_at":"2025-12-02T22:37:37.783347-08:00"}
{"id":"ef-8of","title":"Centralize tool-call rendering with efrit-agent-tool-view struct","description":"Currently tool call rendering is fragmented across three places:\n- efrit-agent--update-tool-result (initial result, collapsed line)\n- efrit-agent--expand-tool / efrit-agent--collapse-tool (toggle)\n- efrit-agent--apply-display-hint (rewriting header with summary/render-type/importance)\n\nAll hand-roll header lines with no single source of truth.\n\nIMPLEMENTATION:\n1. Define cl-defstruct efrit-agent-tool-view with fields:\n   - id, name, input, result, success-p, elapsed, running\n   - render-type, summary, importance, annotations, expanded-p\n\n2. Create efrit-agent--render-tool-call (start tv) function that:\n   - Builds header line with expand/collapse icon based on expanded-p\n   - Shows status icon/color based on success-p and importance\n   - Shows tool name, elapsed time, summary\n   - If expanded-p, appends Input/Result sections with proper formatting\n   - Attaches all tool properties on the full region\n\n3. Refactor existing functions to use the new struct and renderer:\n   - efrit-agent--update-tool-result\n   - efrit-agent--apply-display-hint  \n   - efrit-agent--expand-tool / efrit-agent--collapse-tool\n\nThis fixes the current issue where \"auto-expanded\" items show expanded icon but no body.\n\nFILES: lisp/interfaces/efrit-agent-tools.el","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T20:14:23.219103-08:00","updated_at":"2025-12-03T20:18:49.445747-08:00","closed_at":"2025-12-03T20:18:49.445747-08:00","dependencies":[{"issue_id":"ef-8of","depends_on_id":"ef-3at","type":"blocks","created_at":"2025-12-03T20:14:23.22013-08:00","created_by":"daemon"}]}
{"id":"ef-958","title":"Implement smart summary generation from annotations","description":"Currently collapsed headers show just truncated result text. Need context-sensitive summaries like \"3 files modified (+10/-3)\".\n\nIMPLEMENTATION:\n1. Define summary precedence in render function:\n   - First: explicit summary from Claude's display_hint\n   - Second: format from structured annotations\n   - Third: fallback to truncated result\n\n2. Create efrit-agent--summary-from-annotations function that handles:\n   - :kind diff-summary → \"3 files changed (+10/-4) [foo.py, bar.py]\"\n   - :kind grep-summary → \"7 matches in 3 files for 'foo'\"\n   - :kind test-summary → \"pytest: 1 failed, 23 passed (5.12s)\"\n   - :kind shell-summary → \"make build (exit 0, 10 lines)\"\n   - :kind fs-read-summary → \"Read /path/foo.py (120 lines)\"\n   - :kind fs-write-summary → \"Wrote /path/foo.py (1024 bytes)\"\n\n3. Keep default-summary as robust fallback (truncated result text)\n\nNOTE: The annotation structures are provided by Claude. Emacs just formats them mechanically.\n\nFILES: lisp/interfaces/efrit-agent-tools.el","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T20:14:23.245202-08:00","updated_at":"2025-12-03T20:19:11.994228-08:00","closed_at":"2025-12-03T20:19:11.994228-08:00","dependencies":[{"issue_id":"ef-958","depends_on_id":"ef-8of","type":"blocks","created_at":"2025-12-03T20:14:36.739981-08:00","created_by":"daemon"},{"issue_id":"ef-958","depends_on_id":"ef-3at","type":"parent-child","created_at":"2025-12-03T20:14:36.787315-08:00","created_by":"daemon"}]}
{"id":"ef-98f","title":"Polish: Tool result summary line truncates too aggressively in normal mode","description":"In normal display mode, the tool result summary on the collapsed line is quite short (appears to be ~40 chars based on the code). This sometimes cuts off useful context.\n\nConsider:\n- Increasing the limit for 'normal mode (maybe 60-80 chars)\n- Making truncation length configurable\n- Using window width to determine truncation\n\nCurrent values in efrit-agent--render-activity-item:\n- minimal: 20\n- normal: 40  \n- verbose: 80\n\nNot urgent, just a polish item.","status":"closed","priority":4,"issue_type":"chore","created_at":"2025-12-03T20:47:17.294294-08:00","updated_at":"2025-12-03T22:46:23.567133-08:00","closed_at":"2025-12-03T22:46:23.567133-08:00"}
{"id":"ef-9sy","title":"Agentic buffer interface for Efrit","description":"Design and implement an agentic buffer interface for Efrit, similar to Amp or Claude Code. The current interface relies on efrit-do which takes a command and emits events to a progress buffer. We need a proper interactive buffer-based agent interface that:\n\n- Presents the agent's reasoning, actions, and results in a readable buffer format\n- Allows user interaction (pausing, resuming, modifying instructions mid-task)\n- Integrates with existing tools and APIs we already have\n- Provides better visibility into what the agent is doing\n\nThis would be the primary interface for agentic work, replacing or complementing the current efrit-do command interface.","design":"The agentic buffer should show:\n1. Initial user request/instructions at the top\n2. Agent's reasoning and intermediate steps\n3. Current action being taken\n4. Results of actions\n5. Interactive controls for pausing/resuming\n\nBuild on existing: efrit-chat-buffer.el for display, efrit-tools.el for execution, efrit-do-schema.el for tool definitions","acceptance_criteria":"- Stub issue created with clear vision\n- Initial design decisions documented\n- Technical approach identified","notes":"Implementation tasks created 2025-12-03:\nCORE (P1):\n- ef-33f: Call agent buffer on session start (READY)\n- ef-46k: Stream Claude text content (blocked by ef-33f)\n- ef-4iw: Show tool start/result (blocked by ef-33f)\n- ef-ybp: End session properly (blocked by ef-33f)\n\nINPUT INTEGRATION (P2):\n- ef-r82: Connect input to executor (blocked by core tasks)\n- ef-m0t: Route request_user_input (blocked by ef-r82)\n\nPOLISH (P3-P4):\n- ef-mmy: Syntax highlighting\n- ef-tjd: Collapse/expand defaults\n- ef-zq8: Session persistence\n- ef-7cb: Multi-session support\n\nSee docs/ef-9sy-agentic-buffer-plan.md for full analysis.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-03T10:51:19.741381-08:00","updated_at":"2025-12-03T17:20:51.347292-08:00","closed_at":"2025-12-03T17:20:51.347292-08:00"}
{"id":"ef-9u2","title":"Grep results renderer","description":"Create efrit-agent--render-grep for Grep tool results. Parse ripgrep output format. Group matches by file. Make line numbers clickable to jump to location. Highlight matched text.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:24.925767-08:00","updated_at":"2025-12-03T17:50:01.945443-08:00","closed_at":"2025-12-03T17:50:01.945443-08:00","dependencies":[{"issue_id":"ef-9u2","depends_on_id":"ef-wpj","type":"blocks","created_at":"2025-12-03T17:42:54.876823-08:00","created_by":"daemon"}]}
{"id":"ef-9z1","title":"Make diff file headers clickable to open files","description":"When viewing expanded diff output, make the file header lines clickable to open the file.\n\nIMPLEMENTATION:\n1. In efrit-agent--format-diff-line, detect file header patterns:\n   - \"diff --git a/path b/path\"\n   - \"--- a/path\"\n   - \"+++ b/path\"\n\n2. Extract the file path from these lines\n\n3. Add a keymap with mouse-1 and RET bindings to:\n   - find-file-other-window on the extracted path\n\n4. Apply 'help-echo property showing \"Click to open file\"\n\nThis provides render-type-specific interaction for diffs.\n\nFILES: lisp/interfaces/efrit-agent-tools.el","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-03T20:14:23.26681-08:00","updated_at":"2025-12-03T22:17:13.41037-08:00","closed_at":"2025-12-03T22:17:13.41037-08:00","dependencies":[{"issue_id":"ef-9z1","depends_on_id":"ef-8of","type":"blocks","created_at":"2025-12-03T20:14:36.743318-08:00","created_by":"daemon"},{"issue_id":"ef-9z1","depends_on_id":"ef-3at","type":"parent-child","created_at":"2025-12-03T20:14:36.792878-08:00","created_by":"daemon"}]}
{"id":"ef-9z7","title":"Bug: Duplicate user message in agent buffer on session start","description":"When `efrit-agent--create-buffer` is called, it adds the command as a user message via `efrit-agent--add-user-message`. However, callers may also add the message separately, resulting in the user's command appearing twice.\n\nSeen during dogfooding: the command \"List files in this directory\" appeared twice at the top of the conversation.\n\nFIX: Either remove the `efrit-agent--add-user-message` call from `efrit-agent--create-buffer`, or ensure callers don't duplicate it.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-03T20:47:17.272822-08:00","updated_at":"2025-12-03T20:57:05.346675-08:00","closed_at":"2025-12-03T20:57:05.346675-08:00"}
{"id":"ef-bxb","title":"Agent hangs: \"Wrong type argument: integer-or-marker-p, nil\" during directory walk","description":"User ran: \"M-x efrit-do with the command: let's look at the code in ~/ai/mayor/rigs/gastown/elisp/ -- first visit all the non-test elisp files\"\n\nResult: Agent appears to hang (still showing \"Working 0.0s\"), with error in *Messages* buffer:\n```\nERROR: API request failed: Wrong type argument: integer-or-marker-p, nil\n```\n\nThe agent never completes the task. Need to debug the directory traversal logic.","acceptance_criteria":"Agent successfully visits all non-test .el files in a given directory when asked to browse them, returns within reasonable time, and displays results without errors","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-04T11:33:23.978829-08:00","updated_at":"2025-12-04T14:50:31.554359-08:00","closed_at":"2025-12-04T14:50:31.554359-08:00"}
{"id":"ef-byp","title":"Standardize tool naming between chat and do modes","description":"Inconsistent tool names across modes:\n- buffer_create (do schema) vs create_buffer (chat-tool handling)\n- Chat-only tools (create_buffer, edit_buffer, read_buffer, buffer_info, get_context) not in efrit-do-schema.el\n\nThis makes it hard to reason about \"the set of tools Efrit supports\".\n\nOptions:\n1. Decide on canonical names (prefer existing do schema: buffer_create, buffer_read, etc.)\n2. Add aliases in dispatcher (accept both \"create_buffer\" and \"buffer_create\")\n3. Long-term: derive chat and do schemas from same source\n\nStart with option 2 - add aliases without breaking existing code.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (dispatch table)\n- lisp/core/efrit-do-schema.el (add any missing tools)\n- lisp/core/efrit-chat-api.el (tool handling)","acceptance_criteria":"1. Documented canonical tool naming convention\n2. Both old and new names work via aliases\n3. No behavior change for existing users","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-02T21:58:07.25901-08:00","updated_at":"2025-12-02T23:27:02.989309-08:00","closed_at":"2025-12-02T23:27:02.989309-08:00"}
{"id":"ef-cjg","title":"Missing hook definitions for agent buffer integration","description":"The efrit-agent-integration.el module references hooks like `efrit-progress-tool-start-hook` and `efrit-progress-tool-end-hook` to integrate with the agent buffer, but these hooks are never defined. This means the agent buffer won't receive updates when tools start/end execution.\n\nHooks referenced but not defined:\n- efrit-progress-tool-start-hook\n- efrit-progress-tool-end-hook\n\nImpact: Agent buffer won't display tool execution in real-time, breaking the interactive agentic mode experience.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-03T17:25:57.241594-08:00","updated_at":"2025-12-03T17:26:49.476805-08:00","closed_at":"2025-12-03T17:26:49.476805-08:00"}
{"id":"ef-dbe","title":"Add SECURITY.md documenting trust model and Elisp execution risks","description":"Efrit is effectively \"remote code execution in Emacs\" but this isn't clearly documented.\n\nNeed a SECURITY.md (or README section) covering:\n1. Trust model - Efrit trusts Claude/Anthropic with running arbitrary Elisp\n2. What context is sent (user-login-name, home-directory, recent-files, etc.)\n3. Recommended practices (don't run as root, audit shell whitelist, etc.)\n4. Shell command security and remote access implications","acceptance_criteria":"1. SECURITY.md exists with comprehensive coverage\n2. README links to it prominently","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:47:45.039105-08:00","updated_at":"2025-12-02T22:07:14.686839-08:00","closed_at":"2025-12-02T22:07:14.686839-08:00"}
{"id":"ef-dcm","title":"Accept cwd parameter in MCP server beads_command tool","description":"The beads_command tool in mcp/src/server.ts should accept an optional cwd parameter to specify the working directory for bd commands.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:08:47.210928-08:00","updated_at":"2025-12-02T21:37:50.101945-08:00","closed_at":"2025-12-02T21:37:50.101945-08:00"}
{"id":"ef-dkp","title":"Testing: Create comprehensive agentic mode test suite with mock API","description":"The agentic mode is functional but lacks a comprehensive test suite that can be run without burning API tokens. Currently only basic syntax/load tests exist.\n\nNeeded:\n1. Mock API response handler to simulate Claude's responses\n2. Test scenarios for:\n   - Simple commands (e.g., \"list files in directory\")\n   - Multi-step workflows (tool calls with dependencies)\n   - Error handling and recovery\n   - Streaming and real-time updates\n   - Agent buffer UI rendering for different states\n   - Session lifecycle (start, pause, resume, complete)\n3. Verify async loop state management\n4. Test tool execution ordering and results\n\nThis would enable CI/CD testing without token costs and help catch regressions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:27:21.356737-08:00","updated_at":"2025-12-03T21:11:03.021222-08:00","closed_at":"2025-12-03T21:11:03.021222-08:00"}
{"id":"ef-e0z","title":"Bug: Diff output in tool results not syntax-highlighted","description":"When a tool returns diff output (e.g., from edit_file), it appears as plain text rather than with diff-mode faces.\n\nThe faces are defined in efrit-agent.el (efrit-agent-diff-header, efrit-agent-diff-added, etc.) but they're not being applied to diff content in tool results.\n\nExpected: Lines starting with `+` should be green, `-` should be red, `@@` should be highlighted, etc.\n\nFILES: lisp/interfaces/efrit-agent-tools.el (efrit-agent--format-diff-line should be applying these)","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-03T20:47:17.284613-08:00","updated_at":"2025-12-03T21:00:04.392968-08:00","closed_at":"2025-12-03T21:00:04.392968-08:00"}
{"id":"ef-e3b","title":"Progress buffer appears automatically in efrit-do async - verify this is working","description":"User requirement: The efrit-do working buffer (progress buffer) should automatically appear when efrit-do starts asynchronous execution.\n\nCurrent code shows:\n- efrit-do-async-show-progress-buffer is set to t\n- efrit-do-async-loop is called with show-progress enabled\n- But this hasn't been manually tested\n\nNeed to:\n1. Verify progress buffer auto-displays when running efrit-do (interactive test)\n2. Verify it can be hidden with efrit-do-silently\n3. Verify it can be shown manually with efrit-do-show-progress\n4. Check that window management works correctly (doesn't break existing layout)","acceptance_criteria":"1. Run efrit-do with a test command, verify progress buffer appears automatically without manual action\n2. Run efrit-do-silently, verify no progress buffer appears\n3. Run efrit-do-show-progress, verify it displays the progress buffer\n4. Verify Emacs window layout is reasonable (doesn't delete user's existing windows)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:35.397107-08:00","updated_at":"2025-12-02T20:52:55.560788-08:00","closed_at":"2025-12-02T20:52:55.560788-08:00"}
{"id":"ef-f8q","title":"Documentation: Agentic mode invocation and usage guide","description":"The agentic mode (efrit-do and agent buffer) is functional but lacks clear user-facing documentation on how to use it. Currently users would need to:\n\n1. Find/read the AGENTS.md file  \n2. Understand the agent buffer mode and keybindings\n3. Understand the difference between efrit-chat and efrit-do for interactive work\n\nNeeded:\n- Update README.md or create AGENTIC_MODE.md with clear usage examples\n- Document the agent buffer UI and keybindings\n- Show example workflows (e.g., \"fix a bug\" or \"refactor a function\")\n- Document how to provide feedback/corrections mid-session\n- Explain the difference between chat mode and agentic mode","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:27:14.543849-08:00","updated_at":"2025-12-03T20:23:26.066068-08:00","closed_at":"2025-12-03T20:23:26.066068-08:00"}
{"id":"ef-ge4","title":"Error auto-expansion with visual emphasis","description":"Auto-expand failed tools in smart/verbose display modes. Add visual emphasis for errors (distinct face, icon). Never auto-collapse items user has manually expanded. Ensure error recovery buttons remain prominent.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:30.369283-08:00","updated_at":"2025-12-03T17:50:01.947219-08:00","closed_at":"2025-12-03T17:50:01.947219-08:00","dependencies":[{"issue_id":"ef-ge4","depends_on_id":"ef-y30","type":"blocks","created_at":"2025-12-03T17:42:56.423433-08:00","created_by":"daemon"}]}
{"id":"ef-gwr","title":"Render type syntax highlighting","description":"Map render_type to Emacs major modes for syntax highlighting in expanded view. text→fundamental-mode, diff→diff-mode, elisp→emacs-lisp-mode, json→json-mode, shell→shell-mode, grep→grep-mode, markdown→markdown-mode. Apply highlighting when tool is expanded.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:50:34.572024-08:00","updated_at":"2025-12-03T18:13:08.917817-08:00","closed_at":"2025-12-03T18:13:08.917817-08:00","dependencies":[{"issue_id":"ef-gwr","depends_on_id":"ef-inx","type":"blocks","created_at":"2025-12-03T17:50:53.609668-08:00","created_by":"daemon"}]}
{"id":"ef-h8e","title":"Extract TODO item struct to efrit-todo.el from efrit-do.el","description":"efrit-tools.el declares functions from efrit-do.el for TODO item access:\n- efrit-do-todo-item-status\n- efrit-do-todo-item-priority\n- efrit-do-todo-item-content\n- efrit-do-todo-item-id\n\nThis inverts the dependency: core tools should not depend on workflow-specific code.\n\nCreate efrit-todo.el containing:\n- efrit-do-todo-item struct definition (cl-defstruct)\n- Accessor functions\n- efrit-do--current-todos variable\n- TODO-related helper functions\n\nThen:\n- efrit-do.el requires efrit-todo.el for TODO state management\n- efrit-tools.el requires efrit-todo.el instead of declaring efrit-do functions\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (lines 333-414 - TODO management)\n- lisp/core/efrit-tools.el (lines 61-64 declarations, 826-854 format functions)","acceptance_criteria":"1. efrit-todo.el with struct definition and state management\n2. efrit-tools.el requires efrit-todo.el (no efrit-do declarations)\n3. Cleaner module layering: efrit-todo → efrit-tools → efrit-do","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.22065-08:00","updated_at":"2025-12-02T23:03:24.367937-08:00","closed_at":"2025-12-02T23:03:24.367937-08:00"}
{"id":"ef-hvh","title":"Missing exports in efrit-progress module","description":"The efrit-progress-buffer.el module defines `efrit-progress-create-buffer` and `efrit-progress-show-buffer`, but they are not accessible when requiring efrit-progress. These functions are called by efrit-do-async-loop (line 78-79 of efrit-do-async-loop.el) but fail at runtime because they're not properly exported.\n\nSteps to reproduce:\n1. (require 'efrit-progress)\n2. Try to call efrit-progress-create-buffer - it won't be found\n\nExpected: Functions should be available after requiring the module\nActual: Functions not exported, causing runtime failures when async loop tries to use them","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-03T17:25:54.580961-08:00","updated_at":"2025-12-03T17:26:26.096599-08:00","closed_at":"2025-12-03T17:26:26.096599-08:00"}
{"id":"ef-hy7","title":"Design: Smart output management mode architecture and feature breakdown","description":"Create detailed architectural design for the smart output management mode and break down into concrete implementation tasks.\n\nThis task is the design phase that will self-expand. Deliverables:\n\n1. **Architecture Document**\n   - How tool results are tagged/classified by type\n   - Renderer plugin system for type-specific display\n   - State tracking for expansion toggles across re-renders\n   - Integration with existing efrit-agent buffer rendering\n\n2. **Output Type Registry**\n   - Document all output types we need to handle (file_content, diff, grep_results, json, elisp_eval, etc.)\n   - For each type: what should collapsed view show? expanded view? interaction model?\n   - Examples of smart summarization (e.g., \"Modified 3 files, +47 -12 lines\")\n\n3. **Feature Breakdown**\n   - Analyze Amp/Claude Code output suppression patterns\n   - Define toggle mechanism (maybe a new display mode: minimal/smart/verbose)\n   - Design click-to-expand UX (buttons? overlays? side panel?)\n   - Error handling emphasis (auto-expand failures)\n\n4. **Create Child Tasks**\n   - After analysis, create specific implementation tasks (one per major feature)\n   - Each should be actionable by a coder with clear acceptance criteria\n\nThis task completion means the epic will have full implementation roadmap.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:31:26.373903-08:00","updated_at":"2025-12-03T17:43:29.063192-08:00","closed_at":"2025-12-03T17:43:29.063192-08:00"}
{"id":"ef-i2q","title":"Document when to use efrit-chat vs efrit-do vs efrit-agent","description":"Users (especially those from Claude Code) will be confused about which mode to use:\n\n1. efrit-chat - Multi-turn conversation, buffer-centric tools only\n2. efrit-do - Agentic command execution, full project/file tool suite\n3. efrit-agent - Structured session view for efrit-do\n\nREADME currently doesn't clearly explain:\n- Chat has much smaller tool surface than efrit-do\n- Project-wide refactor/fix workflows should use efrit-do\n- The agent buffer exists and how to use it\n\nThe efrit-agent buffer is one of the nicest parts of Efrit but is never mentioned in README!","acceptance_criteria":"1. README has clear \"When to use\" section explaining each mode\n2. efrit-agent mentioned in Features and Usage sections\n3. Help text improved to guide users to correct mode","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T21:47:45.009469-08:00","updated_at":"2025-12-02T22:05:36.308592-08:00","closed_at":"2025-12-02T22:05:36.308592-08:00"}
{"id":"ef-ibi","title":"Remove backward compatibility cruft from codebase","description":"This is a new codebase - we don't need backward compatibility with older versions.\n\nReview and remove:\n- define-obsolete-function-alias declarations\n- define-obsolete-variable-alias declarations\n- defalias wrappers that exist only for compatibility\n- Comments mentioning deprecated, legacy, backward compatibility\n- Any bridge or adapter code between old/new APIs\n- Variables marked as deprecated (e.g., efrit-api-url in efrit-common.el)\n\nKnown locations to check:\n- lisp/core/efrit-api.el: backward compatibility section at end\n- lisp/core/efrit-common.el: efrit-api-url deprecated variable, efrit-common-truncate-string obsolete alias\n- lisp/core/efrit-chat-api.el: defalias wrappers for efrit--build-headers, efrit--build-tool-result\n\nAfter cleanup:\n- Rename functions to their canonical names (no aliases needed)\n- Remove deprecated variables entirely\n- Update all callers to use the new names directly","acceptance_criteria":"1. No define-obsolete-*-alias in codebase\n2. No defalias used for compatibility (only for genuine semantic aliases)\n3. No deprecated/legacy variables or comments\n4. All functions use their canonical names\n5. make compile passes with no warnings","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-12-02T22:39:04.115703-08:00","updated_at":"2025-12-02T22:40:55.860384-08:00","closed_at":"2025-12-02T22:40:55.860384-08:00"}
{"id":"ef-inx","title":"Add DisplayHint tool","description":"Add DisplayHint tool that Claude calls to control how tool results are displayed. Schema: tool_use_id (required), summary (required), render_type (enum: text/diff/elisp/json/shell/grep/markdown/error), auto_expand (bool), importance (enum: normal/success/warning/error), annotations (array of line/note). Implement handler in efrit-tools that calls efrit-agent--apply-display-hint.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:50:30.412543-08:00","updated_at":"2025-12-03T18:04:30.522796-08:00","closed_at":"2025-12-03T18:04:30.522796-08:00"}
{"id":"ef-jye","title":"Opt-in: efrit-do uses agent buffer UI","description":"Add a customization option to make `M-x efrit-do` automatically show the agent buffer as the primary UI, in addition to (or instead of) the progress buffer.\n\nThis is an optional follow-up for users who want a gradual migration path.\n\n## Acceptance Criteria\n1. New defcustom `efrit-do-use-agent-ui` (default nil)\n2. When nil, `efrit-do` behaves exactly as before (backward compatible)\n3. When t, `efrit-do` also opens/updates the agent buffer\n4. Agent buffer shows the command in conversation, streams responses\n5. Progress buffer still works (both views available)\n6. `make compile` passes","design":"## What to Build\n\nA defcustom flag that, when enabled, hooks efrit-do session starts into the agent buffer.\n\n## Implementation\n\nIn `lisp/interfaces/efrit-do.el`:\n\n```elisp\n(defcustom efrit-do-use-agent-ui nil\n  \"When non-nil, show the efrit-agent buffer for efrit-do sessions.\nThis provides a REPL-like view of command execution alongside\nthe traditional progress buffer.\"\n  :type 'boolean\n  :group 'efrit-do)\n```\n\nModify `efrit-do--start-async-session`:\n\n```elisp\n(defun efrit-do--start-async-session (command)\n  \"Internal helper to start an async efrit-do session for COMMAND.\"\n  ;; Add to history\n  (add-to-history 'efrit-do-history command efrit-do-history-max)\n  ;; Track command execution\n  (efrit-session-track-command command)\n  ;; Create session and start async loop\n  (let ((session (efrit-do--create-session-for-command command)))\n    (message \"Efrit: starting async execution...\")\n    \n    ;; Optionally show agent buffer UI\n    (when efrit-do-use-agent-ui\n      (require 'efrit-agent)\n      (let ((buffer (efrit-agent--get-buffer)))\n        (with-current-buffer buffer\n          (unless (derived-mode-p 'efrit-agent-mode)\n            (efrit-agent-mode))\n          (efrit-agent--begin-session session command))\n        (efrit-agent--show-buffer)))\n    \n    (efrit-do-async-loop session nil #'efrit-do--on-async-complete)\n    session))\n```\n\n## Files to Modify\n- `lisp/interfaces/efrit-do.el`\n\n## Verification Steps\n1. With `efrit-do-use-agent-ui` = nil: `M-x efrit-do` works exactly as before\n2. With `efrit-do-use-agent-ui` = t:\n   - `M-x efrit-do` shows both progress buffer and agent buffer\n   - Agent buffer shows command, streams Claude responses\n   - Both views update in sync\n3. `make compile` passes","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-04T11:46:30.68446-08:00","updated_at":"2025-12-04T11:46:30.68446-08:00","dependencies":[{"issue_id":"ef-jye","depends_on_id":"ef-ofj","type":"blocks","created_at":"2025-12-04T11:46:50.899015-08:00","created_by":"daemon"}]}
{"id":"ef-m0t","title":"Route request_user_input tool to agent buffer","description":"When request_user_input tool runs, show the question in the agent buffer.\n\nCURRENT STATE:\n- efrit-do--handle-request-user-input (efrit-do-handlers.el:567) handles the tool\n- It calls efrit-session-set-pending-question and returns '[WAITING-FOR-USER]'\n- efrit-agent-show-question exists and displays questions with clickable buttons\n- Agent buffer already tracks efrit-agent--pending-question\n\nIMPLEMENTATION OPTIONS:\n\nOPTION A (In tool handler - simpler):\n1. In efrit-do-handlers.el, modify efrit-do--handle-request-user-input (line 567-594)\n2. After setting pending question (line 580-582), add:\n   (require 'efrit-agent)\n   (efrit-agent-show-question question options)\n\nOPTION B (In async loop - more centralized):\n1. In efrit-do-async-loop.el, after tool execution (around line 220)\n2. Detect if tool result contains '[WAITING-FOR-USER]'\n3. Extract question/options from session and call efrit-agent-show-question\n4. This is less clean because question data must be re-fetched from session\n\nRECOMMENDED: Option A is simpler and more direct.\n\nFULL CHANGE for Option A:\nIn efrit-do--handle-request-user-input, after line 582:\n   ;; Show in agent buffer\n   (when (fboundp 'efrit-agent-show-question)\n     (efrit-agent-show-question question options))\n\nUsing fboundp makes it optional - works even if agent module not loaded.\n\nFILES: lisp/interfaces/efrit-do-handlers.el\nVERIFICATION: Run efrit-do with a command like 'ask me a question about colors', verify question appears in agent buffer with options, click an option, verify session continues.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T12:30:44.582313-08:00","updated_at":"2025-12-03T13:21:01.651554-08:00","closed_at":"2025-12-03T13:21:01.651554-08:00","dependencies":[{"issue_id":"ef-m0t","depends_on_id":"ef-r82","type":"blocks","created_at":"2025-12-03T12:31:40.690721-08:00","created_by":"daemon"}]}
{"id":"ef-m1u","title":"Refactor efrit-do session start into reusable helper","description":"Extract the session-start logic from `efrit-do` into a helper function `efrit-do--start-async-session` that can be called from both `efrit-do` (minibuffer path) and the agent buffer (REPL path).\n\nThis maintains the Zero Client-Side Intelligence principle by reusing the same server-side logic for both entry points.\n\n## Acceptance Criteria\n1. New function `efrit-do--start-async-session` created in efrit-do.el\n2. `efrit-do` refactored to call this helper (no behavior change)\n3. Helper adds command to history, tracks command, creates session, starts async loop\n4. Returns the session object for the caller to use\n5. `M-x efrit-do` continues to work exactly as before\n6. `make compile` passes","design":"## What to Build\n\nExtract the no-active-session branch of `efrit-do` into a helper function.\n\n## Implementation\n\nIn `lisp/interfaces/efrit-do.el`, add:\n\n```elisp\n(defun efrit-do--start-async-session (command)\n  \"Internal helper to start an async efrit-do session for COMMAND.\nDoes not prompt or validate; assumes COMMAND is already validated.\nReturns the session object for the caller to attach to their UI.\"\n  ;; Add to history\n  (add-to-history 'efrit-do-history command efrit-do-history-max)\n  ;; Track command execution\n  (efrit-session-track-command command)\n  ;; Create session and start async loop\n  (let ((session (efrit-do--create-session-for-command command)))\n    (message \"Efrit: starting async execution...\")\n    (efrit-do-async-loop session nil #'efrit-do--on-async-complete)\n    session))\n```\n\nThen modify `efrit-do` to use it:\n\n```elisp\n;;;###autoload\n(defun efrit-do (command)\n  ;; ... existing docstring and interactive form ...\n  (when (string-empty-p (string-trim command))\n    (user-error \"Command cannot be empty\"))\n  \n  (if (efrit-session-active)\n      ;; Queue this command for later (existing behavior)\n      (progn\n        (if (efrit-do-queue-add-command command)\n            (message \"Efrit: command queued (position %d)\"\n                     (efrit-do-queue-size))\n          (message \"Efrit: queue full, command not added\"))\n        nil)\n    ;; No active session - use the new helper\n    (efrit-do--start-async-session command)))\n```\n\n## Files to Modify\n- `lisp/interfaces/efrit-do.el`\n\n## Verification Steps\n1. `M-x efrit-do` with a simple command works exactly as before\n2. History is updated correctly\n3. Progress buffer appears\n4. Session completes normally\n5. Queuing still works when a session is active\n6. `make compile` passes","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-04T11:45:06.097184-08:00","updated_at":"2025-12-04T14:51:45.592634-08:00","closed_at":"2025-12-04T14:51:45.592634-08:00"}
{"id":"ef-m9j","title":"Fix stop-reason type inconsistency in efrit-do-async--stop-loop","description":"In efrit-do-async-loop.el line 356, stop-reason is compared as symbol (eq stop-reason 'interrupted) but is passed as string \"interrupted\" from the callers.\n\nThis causes the interrupted status check to always fail, preventing proper error reporting.\n\nThe condition should be: (string= stop-reason \"interrupted\")","acceptance_criteria":"- Verify stop-reason is consistently passed as string throughout async-loop\n- Change line 356 to use string= instead of eq\n- Test that interrupted sessions report correct tool count\n- Compile cleanly with make compile","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-03T15:45:09.041663-08:00","updated_at":"2025-12-03T15:46:32.421769-08:00","closed_at":"2025-12-03T15:46:32.421769-08:00"}
{"id":"ef-mch","title":"Elisp eval is unbounded - can hang Emacs with no timeout","description":"efrit-tools-eval-sexp has no timeout or sandbox around Elisp evaluation. A single misgenerated form (infinite while loop, tight recursion, blocking I/O) can freeze Emacs until user hits C-g.\n\nThis is acceptable for advanced users who understand the risk, but:\n1. README doesn't prominently document this risk\n2. No opt-in timeout mechanism exists\n3. No mention of efrit-tools-sexp-evaluation-enabled config option\n\nSUGGESTED FIX:\nAdd optional timeout wrapping with efrit-tools-eval-timeout custom variable.","acceptance_criteria":"1. Configurable timeout for eval_sexp (default on, reasonable value like 30s)\n2. Document the risk in README's security section\n3. Document efrit-tools-sexp-evaluation-enabled as a safety switch","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:47:44.999174-08:00","updated_at":"2025-12-02T22:30:52.445339-08:00","closed_at":"2025-12-02T22:30:52.445339-08:00"}
{"id":"ef-mmy","title":"Add syntax highlighting in tool result code blocks","description":"Add syntax highlighting for code blocks in tool results.\n\nCURRENT STATE:\n- efrit-agent--format-tool-expansion (line 141) formats expanded tool results\n- efrit-agent--format-indented-lines (line 173) handles text formatting\n- Diff highlighting already exists (efrit-agent--format-diff-content)\n- No general code block highlighting yet\n\nIMPLEMENTATION:\n1. In efrit-agent-tools.el, add a new function after line 173:\n\n   (defun efrit-agent--format-code-block (text language indent max-lines)\n     \"Format TEXT as a code block with LANGUAGE syntax highlighting.\"\n     (let* ((mode (intern-soft (concat language \"-mode\")))\n            (highlighted\n             (if (and mode (fboundp mode))\n                 (with-temp-buffer\n                   (insert text)\n                   (funcall mode)\n                   (font-lock-ensure)\n                   (buffer-string))\n               text)))\n       (efrit-agent--format-indented-lines highlighted indent max-lines)))\n\n2. In efrit-agent--format-tool-expansion (around line 158), detect code blocks:\n   - Look for ```language\\n...\\n``` patterns in result\n   - Extract language and content\n   - Call efrit-agent--format-code-block for each\n\n3. Common language mappings:\n   - elisp/emacs-lisp -\u003e emacs-lisp-mode\n   - python/py -\u003e python-mode\n   - javascript/js -\u003e js-mode\n   - bash/sh/shell -\u003e sh-mode\n\nFILES: lisp/interfaces/efrit-agent-tools.el\nVERIFICATION: Run efrit-do with a command that returns code, expand the tool result, verify syntax highlighting.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-03T12:30:54.844161-08:00","updated_at":"2025-12-03T15:47:49.813389-08:00","closed_at":"2025-12-03T15:47:49.813389-08:00","dependencies":[{"issue_id":"ef-mmy","depends_on_id":"ef-4iw","type":"blocks","created_at":"2025-12-03T12:33:22.144983-08:00","created_by":"daemon"}]}
{"id":"ef-mp4","title":"Summarizer framework and core summarizers","description":"Implement summarizer dispatch system. Create summarizers for: file-content (show path + line count), diff (parse to get +N/-M stats), shell-output (command + exit code), error (brief message). Each produces a one-line collapsed view.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:42:20.401848-08:00","updated_at":"2025-12-03T17:50:01.94367-08:00","closed_at":"2025-12-03T17:50:01.94367-08:00","dependencies":[{"issue_id":"ef-mp4","depends_on_id":"ef-wpj","type":"blocks","created_at":"2025-12-03T17:42:53.470238-08:00","created_by":"daemon"}]}
{"id":"ef-ofj","title":"Support multiple sessions in same agent buffer (REPL persistence)","description":"After a session completes, allow starting a new session in the same agent buffer. The previous conversation becomes static text, and the new session appends below with a clear delimiter.\n\nThis enables true REPL behavior: one persistent buffer, many sessions over time.\n\n## Acceptance Criteria\n1. After session completes, header-line shows \"Complete\"\n2. Typing a new command at prompt starts a new session\n3. Visual delimiter appears between sessions (e.g., \"=== New session ===\")\n4. Header-line resets to \"Working\" with fresh elapsed timer\n5. Previous session's conversation remains visible above (read-only static text)\n6. New session's TODOs and tool counts show in header-line\n7. Can run 2-3 sessions in sequence; buffer remains stable\n8. `make compile` passes","design":"## What to Build\n\nA helper function to reset per-session state while preserving the conversation transcript, and integrate it with the session-start path.\n\n## Implementation\n\nAdd to `lisp/interfaces/efrit-agent-core.el` or `efrit-agent.el`:\n\n```elisp\n(defun efrit-agent--begin-session (session command)\n  \"Attach this agent buffer to SESSION for COMMAND.\nResets per-session state but preserves existing conversation text.\"\n  ;; Set new session context\n  (setq efrit-agent--session-id (efrit-session-id session))\n  (setq efrit-agent--command command)\n  (setq efrit-agent--status 'working)\n  (setq efrit-agent--start-time (current-time))\n  ;; Reset per-session state\n  (setq efrit-agent--todos nil)\n  (setq efrit-agent--activities nil)\n  (setq efrit-agent--pending-question nil)\n  (setq efrit-agent--pending-tools (make-hash-table :test 'equal))\n  (setq efrit-agent--streaming-message nil)\n  (setq efrit-agent--thinking-indicator nil)\n  (setq efrit-agent--todos-region nil)\n  (setq efrit-agent--expansion-state (make-hash-table :test 'equal))\n  ;; Ensure region markers still exist\n  (unless (and efrit-agent--conversation-end\n               (marker-position efrit-agent--conversation-end))\n    (efrit-agent--init-regions)\n    (efrit-agent--setup-regions))\n  ;; Start/restart elapsed timer\n  (when efrit-agent--elapsed-timer\n    (cancel-timer efrit-agent--elapsed-timer))\n  (setq efrit-agent--elapsed-timer\n        (run-at-time 1 1 #'efrit-agent--update-elapsed (current-buffer)))\n  ;; Insert visible delimiter between sessions\n  (efrit-agent--append-to-conversation\n   (propertize (format \"\\n══════════════════════════════════════════════════════════\nSession: %s\n══════════════════════════════════════════════════════════\\n\\n\"\n                       (truncate-string-to-width command 50))\n               'face 'efrit-agent-section-header\n               'efrit-type 'session-delimiter)))\n```\n\nThen modify `efrit-agent-input-send` to use this helper instead of setting state directly:\n\n```elisp\n;; In the \"start new session\" branch:\n(t\n (require 'efrit-do)\n (let ((session (efrit-do--start-async-session input)))\n   (efrit-agent--begin-session session input)\n   (message \"Efrit: started session from agent buffer\")))\n```\n\n## Files to Modify\n- `lisp/interfaces/efrit-agent-core.el` - Add `efrit-agent--begin-session`\n- `lisp/interfaces/efrit-agent-input.el` - Use the new helper\n\n## Verification Steps\n1. Open agent buffer, run a session to completion\n2. Type a new command, press RET\n3. Session delimiter appears in conversation\n4. Header-line resets (Working, fresh elapsed time)\n5. New session works normally\n6. Scroll up to see previous session's content (still readable)\n7. Run 3 sessions in sequence; buffer stays stable\n8. `make compile` passes","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-04T11:45:54.444846-08:00","updated_at":"2025-12-04T11:45:54.444846-08:00","dependencies":[{"issue_id":"ef-ofj","depends_on_id":"ef-27n","type":"blocks","created_at":"2025-12-04T11:46:50.875458-08:00","created_by":"daemon"}]}
{"id":"ef-p91","title":"Display actual model name instead of config reference in chat startup message","description":"The efrit-chat buffer startup message displays \"efrit-config\" instead of the actual model name (e.g., \"claude-3-5-sonnet\"). Users want to know which model is actually being used.","acceptance_criteria":"- Startup message shows the actual model identifier being used\n- Model name is resolved from configuration at startup","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-03T10:45:19.340889-08:00","updated_at":"2025-12-03T10:49:02.539644-08:00","closed_at":"2025-12-03T10:49:02.539644-08:00"}
{"id":"ef-phj","title":"Use shell-quote-argument in efrit-tool-beads.el for safer shell command construction","description":"Security fix: The beads tool functions should use shell-quote-argument when constructing shell commands to prevent injection vulnerabilities.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:08:47.089095-08:00","updated_at":"2025-12-02T21:09:43.087879-08:00","closed_at":"2025-12-02T21:09:43.087879-08:00"}
{"id":"ef-r82","title":"Connect agent buffer input to session executor","description":"Wire efrit-agent-input-send to route user input to the session system.\n\nCURRENT STATE:\n- efrit-agent-input-send (line 168) only displays the message, doesn't execute\n- Session API exists: efrit-session-respond-to-question, efrit-session-set-pending-question\n- efrit-agent--pending-question tracks pending question in agent buffer\n- efrit-session-active returns the current active session\n\nIMPLEMENTATION:\n1. In efrit-agent-input.el, modify efrit-agent-input-send (around line 168-189)\n\n2. After the existing history/display code (around line 183), add:\n   ;; Route to session if active\n   (let ((session (efrit-session-active)))\n     (when session\n       (if (efrit-session-waiting-for-user-p session)\n           ;; Respond to pending question\n           (progn\n             (efrit-session-respond-to-question session input)\n             (setq efrit-agent--pending-question nil)\n             (efrit-agent-set-status 'working))\n         ;; Ad-hoc guidance - inject into session\n         (efrit-session-add-message session 'user input)\n         (message \"Guidance injected to session\"))))\n\n3. Add requires at top of file:\n   (require 'efrit-session)\n   (require 'efrit-session-worklog)\n\nFUNCTIONS AVAILABLE:\n- (efrit-session-active) - returns current session or nil\n- (efrit-session-waiting-for-user-p session) - t if waiting for input\n- (efrit-session-respond-to-question session response) - clears pending, resumes session\n- (efrit-session-add-message session role text) - adds to conversation history\n\nFILES: lisp/interfaces/efrit-agent-input.el\nVERIFICATION: Run efrit-do with a command that asks a question, type response in agent buffer, verify session continues.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T12:30:35.259726-08:00","updated_at":"2025-12-03T13:20:39.471819-08:00","closed_at":"2025-12-03T13:20:39.471819-08:00","dependencies":[{"issue_id":"ef-r82","depends_on_id":"ef-46k","type":"blocks","created_at":"2025-12-03T12:31:34.782207-08:00","created_by":"daemon"},{"issue_id":"ef-r82","depends_on_id":"ef-ybp","type":"blocks","created_at":"2025-12-03T12:31:34.866561-08:00","created_by":"daemon"},{"issue_id":"ef-r82","depends_on_id":"ef-4iw","type":"blocks","created_at":"2025-12-03T12:33:22.104233-08:00","created_by":"daemon"}]}
{"id":"ef-ri7","title":"Extract prompt strings to dedicated *-prompt.el modules","description":"Large prompt strings bloat logic files:\n\n1. efrit-do.el contains prompt-building functions:\n   - efrit-do--command-examples\n   - efrit-do--command-formatting-tools  \n   - efrit-do--command-common-tasks\n   - efrit-do--command-project-workflow\n   - efrit-do--session-protocol-instructions\n\n2. efrit-tools.el has a massive efrit-tools-system-prompt (~200 lines of string concatenation)\n\nCreate:\n- lisp/core/efrit-do-prompt.el - move all efrit-do--command-* functions\n- lisp/core/efrit-tools-prompt.el - move efrit-tools-system-prompt\n\nThis is low-risk cut/paste that immediately reduces file sizes.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (currently ~600 lines omitted in analysis suggests more prompt code)\n- lisp/core/efrit-tools.el (lines 590-789 are system prompt)","acceptance_criteria":"1. efrit-do-prompt.el contains all prompt-building functions\n2. efrit-tools-prompt.el contains efrit-tools-system-prompt\n3. Original files reduced by combined ~400 lines\n4. All tests/compilation still pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.209916-08:00","updated_at":"2025-12-02T22:14:46.324925-08:00","closed_at":"2025-12-02T22:14:46.324925-08:00"}
{"id":"ef-rkc","title":"Add defensive type checking for tool results in agent display","description":"In efrit-agent-tools.el line 107, truncate-string-to-width assumes result is a string. While tool handlers are standardized to return strings, a malformed result could cause errors.\n\nShould add defensive check to ensure result is stringified:\n- Use (format \"%s\" result) before truncate-string-to-width\n- Add comment explaining why this is safe despite handler contracts","acceptance_criteria":"- Add defensive stringification of result\n- Ensure truncate-string-to-width always receives string\n- Compile cleanly\n- No functional behavior change","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-03T15:45:09.067339-08:00","updated_at":"2025-12-03T15:47:13.589115-08:00","closed_at":"2025-12-03T15:47:13.589115-08:00"}
{"id":"ef-rqj","title":"Annotation support in expanded view","description":"When DisplayHint includes annotations array, render line-level notes in expanded view. Use overlays to show annotation text at specified line numbers. Make annotation markers clickable. Optional enhancement for later.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-03T17:50:41.430903-08:00","updated_at":"2025-12-03T22:18:26.411951-08:00","closed_at":"2025-12-03T22:18:26.411951-08:00","dependencies":[{"issue_id":"ef-rqj","depends_on_id":"ef-gwr","type":"blocks","created_at":"2025-12-03T17:50:55.505993-08:00","created_by":"daemon"}]}
{"id":"ef-sgd","title":"Add fboundp guards for agent buffer streaming functions","description":"In efrit-do-async-loop.el lines 179-180, efrit-agent-stream-content and efrit-agent-stream-end are called without fboundp checks.\n\nUnlike request_user_input handler which guards with fboundp, these streaming functions are called on every API response. If the agent module is not loaded, execution stops here instead of gracefully continuing.\n\nShould add fboundp guards:\n- Line 179: (when (fboundp 'efrit-agent-stream-content) ...)\n- Line 180: (when (fboundp 'efrit-agent-stream-end) ...)","acceptance_criteria":"- Add fboundp checks before both stream function calls\n- Verify loop continues even if agent buffer module is not loaded\n- Compile with make compile\n- Verify streaming still works when agent buffer IS loaded","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T15:45:09.055886-08:00","updated_at":"2025-12-03T15:46:45.367701-08:00","closed_at":"2025-12-03T15:46:45.367701-08:00"}
{"id":"ef-t57","title":"Chat mode lacks circuit breaker - only bounded by efrit-max-turns","description":"efrit-do has robust circuit breaker with max-tool-calls-per-session and error-loop detection.\n\nefrit-chat only has efrit-max-turns (default 2) and retry-on-error logic.\n\nIf chat tools keep failing, the model can burn tokens retrying with no per-tool loop detection.\n\nLower priority since max-turns provides some protection.","acceptance_criteria":"Either: add lightweight tool-call tracking to chat, OR document that only efrit-do has circuit breaker semantics","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-02T21:47:45.048556-08:00","updated_at":"2025-12-02T23:39:53.577508-08:00","closed_at":"2025-12-02T23:39:53.577508-08:00"}
{"id":"ef-tjd","title":"Improve tool result collapse/expand defaults","description":"Make long tool results collapsed by default.\n\nCURRENT STATE:\n- Tool results are ALREADY collapsed by default (see line 96-97, 136)\n- efrit-agent--update-tool-result sets efrit-tool-expanded to nil\n- The issue is that ALL results are collapsed, even short ones\n\nREVISED GOAL: Auto-expand SHORT results, keep long ones collapsed.\n\nIMPLEMENTATION:\n1. In efrit-agent--update-tool-result (line 79), add logic to auto-expand short results\n\n2. After line 95 (elapsed-time calculation), add length check:\n   (auto-expand (and success-p\n                     (\u003c (length result) 200)\n                     (\u003c (cl-count ?\\n result) 5)))\n\n3. Use auto-expand to set initial state on line 136:\n   efrit-tool-expanded auto-expand\n\n4. If auto-expand is t, render the expanded view immediately instead of collapsed\n\nALTERNATIVE: Add customization variable:\n   (defcustom efrit-agent-auto-expand-short-results t\n     \"Auto-expand tool results shorter than threshold.\"\n     :type boolean :group efrit-agent)\n   (defcustom efrit-agent-short-result-threshold 200\n     \"Results shorter than this are auto-expanded.\"\n     :type integer :group efrit-agent)\n\nFILES: lisp/interfaces/efrit-agent-tools.el\nVERIFICATION: Run efrit-do, verify short results auto-expand, long results stay collapsed.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-03T12:31:01.996737-08:00","updated_at":"2025-12-03T13:21:39.952543-08:00","closed_at":"2025-12-03T13:21:39.952543-08:00","dependencies":[{"issue_id":"ef-tjd","depends_on_id":"ef-4iw","type":"blocks","created_at":"2025-12-03T12:33:22.186068-08:00","created_by":"daemon"}]}
{"id":"ef-uso","title":"Check for resource leaks in async execution loop","description":"User requirement: No resource leaks before release.\n\nAreas to audit:\n1. Buffer cleanup - are temporary buffers closed after sessions end?\n2. Timer cleanup - are all timers canceled when sessions end?\n3. Hash table cleanup - are session loops removed from tracking?\n4. HTTP connections - are URL requests properly closed?\n5. File handles - are any files left open after operations?\n\nCurrent code analysis shows:\n- efrit-do-async-loop.el properly cleans up via remhash (line 350)\n- Progress buffers may accumulate if many sessions run\n- One-shot timers in callbacks aren't tracked (efrit-do.el:1188, efrit-remote-queue.el:526)\n- Need to verify real cleanup under heavy load\n\nTesting needed:\n1. Run 10+ sequential efrit-do commands, check buffer count\n2. Monitor timer objects with (timer-list)\n3. Check for orphaned processes\n4. Stress test with concurrent commands and queueing\n5. Check memory growth over time","acceptance_criteria":"After running 10+ commands in quick succession, verify: no accumulation of buffers, no orphaned timers, no memory growth, no file descriptor leaks","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T18:08:50.308795-08:00","updated_at":"2025-12-02T20:56:50.945684-08:00","closed_at":"2025-12-02T20:56:50.945684-08:00"}
{"id":"ef-w3r","title":"Enhanced diff renderer","description":"Improve current diff rendering with better unified diff parsing. Show file stats (+N -M) in collapsed header. Improve diff faces for added/removed/context lines. Add clickable file paths that jump to location.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:23.944467-08:00","updated_at":"2025-12-03T17:50:01.944962-08:00","closed_at":"2025-12-03T17:50:01.944962-08:00","dependencies":[{"issue_id":"ef-w3r","depends_on_id":"ef-wpj","type":"blocks","created_at":"2025-12-03T17:42:54.834202-08:00","created_by":"daemon"}]}
{"id":"ef-whm","title":"efrit-chat-api.el: split API communication from tool handling","description":"efrit-chat-api.el (1077 lines) mixes:\n1. HTTP/API request building and response parsing\n2. Classic chat mode message handling\n3. Streamlined mode implementation\n4. Tool call extraction and execution\n5. UI updates (efrit--display-message, etc.)\n\nAfter extracting shared API client (ef-xxx), consider further splitting:\n- efrit-chat-transport.el: HTTP layer (if not moved to efrit-api.el)\n- efrit-chat-classic.el: Classic multi-turn chat mode\n- efrit-chat-streamlined.el: Streamlined mode (~200 lines starting at line 664)\n\nThis is lower priority since the shared API extraction addresses the main duplication.\n\nFiles affected:\n- lisp/core/efrit-chat-api.el","acceptance_criteria":"1. Clear separation of concerns if split performed\n2. Each file under 400 lines\n3. Tests pass","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-02T21:58:07.267796-08:00","updated_at":"2025-12-02T23:51:24.282539-08:00","closed_at":"2025-12-02T23:51:24.282539-08:00"}
{"id":"ef-wpj","title":"Output type classification system","description":"Add efrit-agent-output-types registry mapping tool names to output types (file-content, diff, grep-results, shell-output, etc). Implement efrit-agent--classify-output function. Support type detection from result content patterns when tool name alone is insufficient.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:42:19.405636-08:00","updated_at":"2025-12-03T17:50:01.939979-08:00","closed_at":"2025-12-03T17:50:01.939979-08:00","dependencies":[{"issue_id":"ef-wpj","depends_on_id":"ef-hy7","type":"blocks","created_at":"2025-12-03T17:42:57.753472-08:00","created_by":"daemon"}]}
{"id":"ef-xep","title":"Add efrit REPL entry command","description":"Create a simple, memorable `M-x efrit` command as the recommended entry point to the REPL-style interface.\n\nThis gives users a single discoverable command that opens the agent buffer with point at the input prompt.\n\n## Acceptance Criteria\n1. `M-x efrit` opens the agent buffer\n2. Buffer appears at bottom (or reuses existing window)\n3. Point is placed at the input prompt, ready to type\n4. Existing buffer is reused if already open\n5. Works in all states: idle, working, complete, failed\n6. Docstrings updated to recommend this as primary interface\n7. `make compile` passes","design":"## What to Build\n\nA simple entry command that wraps `efrit-agent-open` with focus behavior.\n\n## Implementation\n\nAdd to `lisp/interfaces/efrit-agent.el`:\n\n```elisp\n;;;###autoload\n(defun efrit ()\n  \"Open the Efrit REPL-style agent buffer.\nType at the \u003e prompt to start a session, or continue an active one.\n\nThis is the recommended way to interact with Efrit.\nFor one-off commands without the REPL UI, use \\\\[efrit-do] instead.\"\n  (interactive)\n  (efrit-agent-open)\n  ;; Ensure focus is in the input region\n  (when-let ((win (get-buffer-window efrit-agent-buffer-name)))\n    (select-window win)\n    (with-current-buffer efrit-agent-buffer-name\n      (goto-char (point-max))\n      (when (and efrit-agent--input-start\n                 (marker-position efrit-agent--input-start))\n        (goto-char efrit-agent--input-start)))))\n```\n\nAlso update docstrings in `efrit-do.el`:\n\n```elisp\n;;;###autoload\n(defun efrit-do (command)\n  \"Execute natural language COMMAND in Emacs asynchronously.\n\nFor a REPL-style experience with a persistent prompt buffer,\nuse \\\\[efrit] instead.\n\nThis command is useful for:\n- One-off commands where you don't need the REPL interface\n- Scripting and automation\n- When you prefer the minibuffer workflow\n...\"\n```\n\n## Files to Modify\n- `lisp/interfaces/efrit-agent.el` - Add the `efrit` command\n- `lisp/interfaces/efrit-do.el` - Update docstring to mention efrit\n\n## Verification Steps\n1. `M-x efrit` opens agent buffer\n2. Point is at `\u003e ` prompt, ready to type\n3. Typing and pressing RET starts a session\n4. Running `M-x efrit` again when buffer exists focuses it\n5. Works whether session is active or not\n6. `make compile` passes","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-04T11:46:12.724886-08:00","updated_at":"2025-12-04T11:46:12.724886-08:00","dependencies":[{"issue_id":"ef-xep","depends_on_id":"ef-ofj","type":"blocks","created_at":"2025-12-04T11:46:50.891004-08:00","created_by":"daemon"}]}
{"id":"ef-xjh","title":"Persistent expansion state across re-renders","description":"Add efrit-agent--expansion-state hash table. Track user-set vs auto-set expansion. Preserve expansion state across buffer re-renders. User toggles set user-set flag that prevents auto-changes.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-03T17:42:27.904617-08:00","updated_at":"2025-12-03T17:50:01.946412-08:00","closed_at":"2025-12-03T17:50:01.946412-08:00","dependencies":[{"issue_id":"ef-xjh","depends_on_id":"ef-y30","type":"blocks","created_at":"2025-12-03T17:42:56.338836-08:00","created_by":"daemon"}]}
{"id":"ef-xmw","title":"CRITICAL: efrit-chat and efrit-do have very different tool sets - NOT feature parity","description":"CRITICAL ISSUE: efrit-chat only has 8 basic tools while efrit-do has 34 comprehensive tools.\n\nefrit-chat tools (hardcoded in efrit-chat-api.el lines 222-304):\n1. eval_sexp\n2. get_context\n3. resolve_path\n4. read_image\n5. create_buffer\n6. edit_buffer\n7. read_buffer\n8. buffer_info\n\nefrit-do tools (via efrit-do-schema.el):\n- All 8 chat tools PLUS\n- shell_exec\n- todo_write\n- session_complete\n- glob_files\n- request_user_input\n- confirm_action\n- checkpoint/restore\n- show_diff_preview\n- web_search\n- fetch_url\n- project_files\n- search_content\n- read_file\n- edit_file\n- create_file\n- file_info\n- vcs_status/diff/log/blame\n- elisp_docs\n- set_project_root\n- get_diagnostics\n- format_file\n- undo_edit\n- display_in_buffer\n- format_file_list\n- format_todo_list\n\nThis breaks the user requirement that efrit-chat should have access to all the same tools as efrit-do.\n\nBlocker for release until resolved.","acceptance_criteria":"efrit-chat must have access to all 34 tools available in efrit-do, OR the user must be clearly informed that efrit-chat is intentionally limited (not recommended for one-off tasks that need file operations)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T18:09:00.3812-08:00","updated_at":"2025-12-02T18:14:46.073883-08:00","closed_at":"2025-12-02T18:14:46.073883-08:00"}
{"id":"ef-xx4","title":"Shell security: ssh/scp/rsync allowed by default - document remote host risk","description":"efrit-do-allowed-shell-commands includes ssh, scp, and rsync by default.\n\nThis means Claude can connect to any host in user's SSH config, copy files to/from remote systems, and execute commands on remote systems.\n\nThe shell security section in README doesn't highlight this remote-host risk.\n\nOPTIONS:\nA) Remove ssh/scp/rsync from default whitelist\nB) Add prominent documentation warning\nC) Add separate remote access tool category","acceptance_criteria":"1. Either: ssh/scp/rsync removed from defaults, OR clear documentation about remote access implications\n2. Warning when using (\"*\") or disabling security","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T21:47:45.029476-08:00","updated_at":"2025-12-02T22:07:25.784341-08:00","closed_at":"2025-12-02T22:07:25.784341-08:00"}
{"id":"ef-y30","title":"Display mode infrastructure (minimal/smart/verbose)","description":"Add efrit-agent-display-mode custom variable with three modes. Add M keybinding to cycle modes. Show current mode in header-line. Implement mode-based default expansion logic (minimal=all collapsed, smart=errors expanded, verbose=all expanded).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T17:42:21.55309-08:00","updated_at":"2025-12-03T17:50:01.944175-08:00","closed_at":"2025-12-03T17:50:01.944175-08:00","dependencies":[{"issue_id":"ef-y30","depends_on_id":"ef-mp4","type":"blocks","created_at":"2025-12-03T17:42:53.514635-08:00","created_by":"daemon"}]}
{"id":"ef-ybp","title":"End agent session properly on loop completion","description":"Signal session completion to the agent buffer when the async loop ends.\n\nCURRENT STATE:\n- efrit-agent-set-status exists and works with: working, paused, waiting, complete, failed\n- No efrit-agent-end-session function exists yet\n- efrit-do-async--stop-loop (line 319) handles session termination\n\nIMPLEMENTATION:\n\nAPPROACH A (Recommended - Add public function):\n1. In efrit-agent.el, add after efrit-agent-set-status (around line 811):\n   (defun efrit-agent-end-session (success-p)\n     \"End the current agent session.\n   SUCCESS-P determines whether to show complete or failed status.\"\n     (efrit-agent-set-status (if success-p 'complete 'failed)))\n\n2. In efrit-do-async--stop-loop (line 319), add after line 327:\n   (efrit-agent-end-session (string= stop-reason \"end_turn\"))\n\nAPPROACH B (Use set-status directly):\n1. In efrit-do-async--stop-loop, add after line 327:\n   (efrit-agent-set-status\n     (if (string= stop-reason \"end_turn\") 'complete 'failed))\n\nCONTEXT - stop-reason values:\n- \"end_turn\" = Claude finished successfully\n- \"interrupted\" = User interrupted (C-g)\n- \"api-error\" = API call failed\n- \"iteration-limit-exceeded\" = Hit max iterations\n- \"session-complete\" = Tool signaled completion\n- \"unknown-stop-reason\" = Unexpected stop reason\n\nAll non-\"end_turn\" reasons should show 'failed status.\n\nFILES: lisp/interfaces/efrit-agent.el, lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run efrit-do to completion, verify agent buffer shows 'complete' status. Then interrupt with C-g, verify it shows 'failed'.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:30:25.038094-08:00","updated_at":"2025-12-03T13:19:34.09045-08:00","closed_at":"2025-12-03T13:19:34.09045-08:00","dependencies":[{"issue_id":"ef-ybp","depends_on_id":"ef-33f","type":"blocks","created_at":"2025-12-03T12:31:29.304746-08:00","created_by":"daemon"}]}
{"id":"ef-z3e","title":"Feature: Add verbosity cycling to agent buffer (v key)","description":"The agent buffer has a verbosity cycling feature documented in the help (v key cycles between minimal/normal/verbose), but this is good UX that could be made more discoverable.\n\nThe feature exists and works, but consider:\n1. Making verbosity level visible in the header-line\n2. Adding visual indicator (e.g., \"Verbosity: normal\")\n3. Perhaps binding to 'v' command for quick access\n\nThis is more of a polish/UX improvement since the feature already exists.","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-03T17:27:17.519261-08:00","updated_at":"2025-12-03T22:16:29.94137-08:00","closed_at":"2025-12-03T22:16:29.94137-08:00"}
{"id":"ef-zq8","title":"Add session persistence for agent buffer","description":"Save and restore agent buffer conversation when buffer is killed.\n\nCURRENT STATE:\n- efrit-transcript-save saves session to disk\n- efrit-transcript-load loads session by ID\n- efrit-transcript-list returns available transcripts\n- efrit-agent-mode has kill-buffer-hook for cleanup (line 263)\n\nIMPLEMENTATION:\n1. Add save-on-kill in efrit-agent-core.el:\n   - In kill-buffer-hook (already exists), call transcript save\n   - Only save if session has content worth saving\n\n2. Add restore option in efrit-agent-start-session (to be created in ef-33f):\n   - Check if transcript exists for session-id\n   - If exists, prompt: Restore previous session? y/n\n   - If yes, load and replay messages to agent buffer\n\n3. Key functions to use:\n   (efrit-transcript-save session) - saves session\n   (efrit-transcript-load session-id) - returns session struct or nil\n   (efrit-session-conversation-history session) - gets messages\n\n4. Restore flow:\n   (let ((old-session (efrit-transcript-load session-id)))\n     (when (and old-session (y-or-n-p \"Restore previous session? \"))\n       (dolist (msg (efrit-session-conversation-history old-session))\n         (let ((role (nth 0 msg)) (content (nth 1 msg)))\n           (pcase role\n             (user (efrit-agent--add-user-message content))\n             (assistant (efrit-agent--add-claude-message content)))))))\n\nFILES: lisp/interfaces/efrit-agent-core.el, lisp/core/efrit-session-transcript.el\nVERIFICATION: Run efrit-do, let it complete, kill buffer, run efrit-agent, verify restore prompt appears.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-03T12:31:10.055122-08:00","updated_at":"2025-12-03T15:48:41.6057-08:00","closed_at":"2025-12-03T15:48:41.6057-08:00","dependencies":[{"issue_id":"ef-zq8","depends_on_id":"ef-ybp","type":"blocks","created_at":"2025-12-03T12:31:40.823738-08:00","created_by":"daemon"}]}
{"id":"ef-zsd","title":"Add Beads MCP tool to Efrit","description":"Give Efrit access to beads CLI through MCP server. This allows Efrit to:\n- Check ready work (bd ready)\n- Create issues (bd create)\n- Update issue status (bd update)\n- Close issues (bd close)\n- List and query issues (bd list)\n- Inspect dependencies (bd show)\n\nShould be implemented as an MCP tool in the TypeScript/Node MCP server.","acceptance_criteria":"Efrit can execute beads commands through MCP and receive structured results. At minimum: bd ready, bd create, bd update, bd close, bd list","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T18:27:05.1739-08:00","updated_at":"2025-12-02T20:55:12.528625-08:00","closed_at":"2025-12-02T20:55:12.528625-08:00"}
