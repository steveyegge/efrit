{"id":"ef-0e9","title":"Create tool-input validator/accessor class to replace ad-hoc gethash patterns in handlers","description":"The tool handlers in `efrit-do-handlers.el` repeatedly extract fields from tool-input hash tables with patterns like:\n\n```elisp\n(gethash \"todos\" tool-input)\n(gethash \"content\" todo-data \"\")\n(gethash \"status\" todo-data \"pending\")\n(gethash \"pattern\" tool-input)\n(gethash \"extension\" tool-input)\n(gethash \"recursive\" tool-input)\n(gethash \"question\" tool-input)\n(gethash \"options\" tool-input)\n```\n\nAnd include validation/defaults logic scattered throughout:\n- Lines 240-250: Extract and validate todos array\n- Lines 299-307: Extract mode with fallback/conversion\n- Lines 324-326: Extract and intern sort_by field\n- Lines 362-364: Multiple fields with default values\n- Lines 438-450: Extract question/options with fallbacks\n\nCreate EIEIO classes or validation helper functions for each tool input type:\n- `efrit-tool-input-base` - Common validation interface\n- `efrit-todo-write-input` - Validate/extract todos array\n- `efrit-buffer-create-input` - Validate name, content, mode\n- `efrit-glob-files-input` - Validate pattern, extension, recursive\n- `efrit-request-user-input-input` - Validate question, options\n\nEach class should have:\n- Slot validation (required/optional fields, types)\n- Accessor methods (get-field-safe with defaults)\n- Conversion helpers (string→symbol for enums)\n\nFiles affected: efrit-do-handlers.el lines 240-450.","acceptance_criteria":"All ad-hoc gethash+conversion patterns in efrit-do-handlers replaced with class accessors. Tests pass.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T18:18:00.133447-08:00","updated_at":"2025-11-30T18:39:40.345394-08:00","closed_at":"2025-11-30T18:39:40.345394-08:00","close_reason":"Created EIEIO-based tool input validators and refactored all handlers to use them"}
{"id":"ef-14q","title":"efrit-agent: Not available in autoload list","description":"efrit-agent module exists and loads when dependencies are available, but it's not registered in the autoload list in efrit.el. This means:\n\n1. M-x efrit-agent won't work without (require 'efrit-agent)\n2. The new agent buffer support isn't accessible to users\n3. It's inconsistent with how efrit-chat, efrit-do, etc. are exposed\n\nThe module at lisp/interfaces/efrit-agent.el has a public function efrit-agent but no autoload declaration in efrit.el.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-11-30T16:50:48.378723-08:00","updated_at":"2025-11-30T16:51:45.604501-08:00","closed_at":"2025-11-30T16:51:45.604501-08:00","close_reason":"Added efrit-agent to autoload list in efrit.el, also added to keybindings and help text"}
{"id":"ef-387","title":"Create metrics and stats accessor module to replace ad-hoc alist extraction in UI","description":"The `efrit-ui-dashboard.el` module (lines 113-160) and other UI code extract metrics from alist structures with repeated `cdr (assoc ...)` patterns:\n\n```elisp\n(cdr (assoc 'tool-calls stats))\n(cdr (assoc 'total-time stats))\n(cdr (assoc 'average-response-time stats))\n```\n\nSimilarly, `efrit-session-metrics.el` likely builds these stats with inconsistent structure.\n\nCreate `efrit-metrics.el` module with:\n- `efrit-session-metrics` EIEIO class with slots for all tracked metrics:\n  - tool-calls, total-time, average-response-time, buffer-modifications, files-modified, errors, etc.\n  - Validation: no negative numbers, reasonable ranges\n- Accessor methods with defaults: `efrit-metrics-get-tool-calls(metrics)` → number\n- Builder methods: `efrit-metrics-from-session(session)` → metrics object\n- Display helpers: `efrit-metrics-format-for-dashboard(metrics)` → string\n\nThis makes metrics handling:\n- Type-safe (EIEIO slots are validated)\n- Extensible (add metrics without breaking existing accessors)\n- Testable (create test metrics directly)\n- Self-documenting (slot names are clear)\n\nFiles affected: efrit-ui-dashboard.el (lines 113-160), efrit-session-metrics.el.","acceptance_criteria":"Metrics alist patterns replaced with EIEIO class. Dashboard uses accessor methods. Tests verify metrics building. No behavioral changes.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-11-30T18:18:20.818684-08:00","updated_at":"2025-11-30T18:54:25.883762-08:00","closed_at":"2025-11-30T18:54:25.883762-08:00","close_reason":"Completed - Created efrit-metrics.el with EIEIO class for session metrics. Provides type-safe accessors for commands-executed, todos, API calls, files, buffers, and tools. Added statistics methods and display helpers. Added 22 passing tests."}
{"id":"ef-3ne","title":"efrit-chat: No session persistence or history navigation","description":"Unlike ChatGPT where you can:\n- View conversation history\n- Search/filter past conversations\n- Branch conversations at a specific point\n- Load old conversations back into the current session\n\nefrit-chat currently:\n- Has no persistent history across sessions\n- No way to view old conversations\n- Has (efrit-chat-persistence) module but only saves current session, no browsing\n- Clearing conversation with efrit-chat-clear loses everything\n\nWould benefit from:\n- Easy conversation history browser/search\n- Ability to recall previous responses\n- Export conversations to files\n- Resume previous conversations\"","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-11-30T17:14:30.68918-08:00","updated_at":"2025-11-30T18:02:04.638777-08:00","closed_at":"2025-11-30T18:02:04.638777-08:00","close_reason":"Implemented comprehensive session persistence and history navigation. Created efrit-chat-history.el module that extends existing persistence with: (1) efrit-chat-history-preview - preview most recent session before restoring, (2) efrit-chat-history-search - search sessions by content/ID, (3) efrit-chat-history-export-session - export conversations to text files, (4) efrit-chat-history-list-enhanced - display sessions with better formatting. Core features already implemented in efrit-chat-persistence.el: session auto-save, session restore, list sessions, delete sessions, cleanup old sessions. All tests verify persistence, restoration, export, and search work correctly."}
{"id":"ef-4iy","title":"efrit-chat: Missing conversation flow and transparency features","description":"Current efrit-chat treats each message as independent - there's no higher-level conversation state or multi-turn task orchestration. Compared to ChatGPT/Claude desktop:\n\nMissing features:\n1. No ability to have Claude ask clarifying questions in a natural way\n2. No natural back-and-forth for multi-step operations\n3. Tool execution happens silently - user can't see what tools Claude is calling or why\n4. No streaming or incremental response display (all or nothing)\n5. No visible \\\"thinking\\\" or step-by-step execution display\n\nThis makes conversations feel less natural and less transparent. Users can't see Claude's reasoning process.\"","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-11-30T17:14:24.219059-08:00","updated_at":"2025-11-30T17:43:07.030565-08:00","closed_at":"2025-11-30T17:43:07.030565-08:00","close_reason":"Implemented core transparency features: tool call visibility, incremental response display, thinking/reasoning display. Created comprehensive test suite and documentation. Addresses main pain points in the issue.\""}
{"id":"ef-5w5","title":"Create result extraction helpers for tool-result plist patterns","description":"Throughout the codebase, we build and extract from tool-result plists with repeated patterns:\n\nLines in efrit-executor.el:\n- 220-229: Building tool-result plist with :result, :is-error, :tool-id, :session-complete, :completion-message, :work-log-entry\n- 268-270: Extracting fields with plist-get for building tool_result blocks\n- 368-371: Extracting :result-text, :tool-result-blocks, :tool-results-for-work-log, :completion-message\n\nAlso in efrit-do-handlers.el:\n- Multiple places building result structures with inconsistent key naming\n\nThis creates mental friction when reading code - you have to remember which plist keys are used where.\n\nCreate helper module `efrit-result-struct.el` with:\n- `efrit-tool-result` EIEIO class for immutable result objects\n  - Slots: result (string), is-error (bool), tool-id (string), session-complete (bool), completion-message (string), work-log-entry (list)\n  - Factory: `efrit-tool-result-make(...)`\n  - Accessors: `efrit-tool-result-is-error(result)`, etc.\n  - Converters: `efrit-tool-result-to-plist()`, `efrit-tool-result-from-plist(plist)`\n\n- `efrit-content-result` EIEIO class for content processing results\n  - Slots: result-text, tool-result-blocks, tool-results-for-work-log, completion-message, session-complete\n  - Factory: `efrit-content-result-make(...)`\n  - Accessors\n\nThis eliminates magic plist keys and makes the code more self-documenting.\n\nFiles affected: efrit-executor.el (lines 220-229, 268-270, 368-371), efrit-do-handlers.el.","acceptance_criteria":"Result plists replaced with EIEIO objects and accessors. Tests verify round-trip conversion. No behavioral changes.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-11-30T18:18:15.477188-08:00","updated_at":"2025-11-30T18:53:20.312111-08:00","closed_at":"2025-11-30T18:53:20.312111-08:00","close_reason":"Completed - Created efrit-result-struct.el with EIEIO classes for tool-result and content-result. Provides type-safe accessors and conversion to/from plists for backward compatibility. Added 25 passing tests."}
{"id":"ef-6sp","title":"Abstract diff extraction logic in agent-tools rendering","description":"In `efrit-agent-tools.el` (lines 210-221), the `efrit-agent--extract-diff-from-result` function has a complex cond block checking multiple diff formats:\n\n```elisp\n(cond\n ((and (listp result) (assoc 'diff result)) ...)\n ((stringp result) ...)\n ((and (stringp result) (string-match (json-encode ...))) ...)\n```\n\nThis is fragile because:\n1. It assumes specific result data formats\n2. Multiple fallback checks make it hard to add new formats\n3. The logic should be centralized near where diffs are created\n\nCreate `efrit-diff.el` module with:\n- `efrit-diff` EIEIO class (content, format, line-range, metadata)\n- Factory functions for different input formats:\n  - `efrit-diff-from-alist(alist)` - handle {diff: ...} format\n  - `efrit-diff-from-string(string)` - handle plain diff text\n  - `efrit-diff-from-json(json-string)` - handle stringified JSON\n- Validator: `efrit-diff-valid-p(diff)` → bool\n- Accessor: `efrit-diff-get-content(diff)` → string\n- Formatter: `efrit-diff-format-for-display(diff)` → propertized string\n\nThis makes diff handling:\n- Type-safe (EIEIO validation)\n- Discoverable (all diff creation patterns in one place)\n- Testable (create test diffs directly)\n\nFiles affected: efrit-agent-tools.el (lines 210-221), likely efrit-tools.el where diffs are created.","acceptance_criteria":"Diff extraction logic moved to EIEIO class. Agent-tools uses factory functions. Tests cover all input formats. No behavioral changes.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-11-30T18:18:25.851292-08:00","updated_at":"2025-11-30T18:56:02.560606-08:00","closed_at":"2025-11-30T18:56:02.560606-08:00","close_reason":"Completed - Created efrit-diff.el with EIEIO class for diff abstraction. Provides factory functions for extracting diffs from alists, strings, and other formats. Includes diff validation, line type detection, statistics (additions/deletions count), and display formatting. Added 32 passing tests."}
{"id":"ef-7xe","title":"efrit-chat: efrit-send-message fails when called programmatically","description":"When calling efrit-send-message programmatically (not via M-x), the message parameter is nil, causing \"Wrong type argument: stringp, nil\" error. This breaks batch testing and programmatic use of efrit-chat.\n\nSteps to reproduce:\n1. Create efrit-chat buffer\n2. Call (efrit-send-message \"test message\") directly\nResult: Error - message is nil\nExpected: Message is sent to API\n\nThe issue is that when called non-interactively, the message parameter isn't being bound properly.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-11-30T16:50:48.358441-08:00","updated_at":"2025-11-30T16:51:29.787493-08:00","closed_at":"2025-11-30T16:51:29.787493-08:00","close_reason":"Fixed by making efrit-chat return the buffer it creates and sets up"}
{"id":"ef-9la","title":"efrit-chat: Model version is outdated and causes API failures","description":"efrit-chat and efrit-chat-api were hardcoded to use 'claude-3-5-sonnet-20241022', an older model that no longer exists in the Anthropic API. This causes all chat messages to fail with 404/not_found_error responses.\n\nThe root cause was hardcoded model string instead of using efrit-default-model like efrit-do does.\n\nTesting confirmed:\n- efrit-do works correctly with the same API key\n- The correct model is 'claude-sonnet-4-5-20250929' as used in efrit-config\n\nFixed by updating chat modules to use efrit-default-model from efrit-config.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-11-30T17:13:42.72023-08:00","updated_at":"2025-11-30T17:13:44.289488-08:00","closed_at":"2025-11-30T17:13:44.289488-08:00","close_reason":"Fixed - updated efrit-chat and efrit-chat-api to use efrit-default-model from config instead of hardcoded deprecated model string\""}
{"id":"ef-a0o","title":"efrit-agent: Major mode not initialized when buffer is created","description":"The efrit-agent() function had inverted logic - it only activated efrit-agent-mode when the buffer was NOT live, but get-buffer-create always creates a live buffer. Result: efrit-agent buffer was in fundamental-mode instead of efrit-agent-mode.\n\nFixed by checking major-mode instead of buffer-live-p.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-11-30T16:53:01.054829-08:00","updated_at":"2025-11-30T16:53:02.48412-08:00","closed_at":"2025-11-30T16:53:02.48412-08:00","close_reason":"Fixed by checking major-mode instead of buffer-live-p"}
{"id":"ef-cs7","title":"Add API response accessor functions to replace nested gethash calls","description":"The executor code frequently accesses deeply nested hash tables from Claude API responses with patterns like:\n\n```elisp\n(gethash \"error\" response)\n(gethash \"type\" error-obj)\n(gethash \"message\" error-obj)\n(gethash \"content\" response)\n(gethash \"stop_reason\" response)\n```\n\nCreate accessor functions in a new module `efrit-chat-response.el` to abstract API response structure:\n\n- `efrit-response-error(response)` → error-obj or nil\n- `efrit-error-type(error-obj)` → string\n- `efrit-error-message(error-obj)` → string\n- `efrit-response-content(response)` → vector\n- `efrit-response-stop-reason(response)` → string\n- `efrit-response-usage(response)` → usage-obj or nil\n- `efrit-content-item-type(item)` → \"text\" | \"tool_use\"\n- `efrit-content-item-text(item)` → string or nil\n- `efrit-content-item-as-tool-use(item)` → (tool-id tool-input) or nil\n\nThis centralizes the API contract in one place and makes response handling more maintainable.\n\nFiles affected: efrit-executor.el (lines 349-380, 251-290, 635-652).","acceptance_criteria":"All nested gethash patterns in efrit-executor replaced with accessor functions. Tests pass. No behavioral changes.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T18:17:54.516425-08:00","updated_at":"2025-11-30T18:33:13.845575-08:00","closed_at":"2025-11-30T18:33:13.845575-08:00","close_reason":"Closed via update"}
{"id":"ef-dit","title":"Create event formatter/accessor class to replace alist cdr patterns in progress module","description":"The `efrit-progress.el` module has repetitive patterns extracting fields from event alists with:\n\n```elisp\n(cdr (assoc \"type\" event))\n(cdr (assoc \"timestamp\" event))\n(cdr (assoc \"command\" event))\n(cdr (assoc \"tool\" event))\n(cdr (assoc \"repeat_count\" event))\n(cdr (assoc \"success\" event))\n```\n\nLines 677-710 in `efrit-progress--format-event` have multiple fallback patterns and conditional formatting logic for different event types.\n\nCreate an event abstraction:\n- `efrit-event` EIEIO class with slots: type, timestamp, data\n- Subclasses for each event type:\n  - `efrit-session-start-event` - command\n  - `efrit-session-end-event` - success\n  - `efrit-tool-start-event` - tool, repeat_count\n  - `efrit-tool-result-event` - tool, success\n  - `efrit-tool-error-event` - tool, error-message\n- Accessor methods to handle missing fields with sensible defaults\n- Formatter methods for each event type (replaces pcase branches)\n\nThis makes event handling testable and centralizes event schema.\n\nFiles affected: efrit-progress.el lines 499-500, 677-710.","acceptance_criteria":"Event alist patterns replaced with EIEIO classes. Event formatter uses class methods. Tests pass.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-11-30T18:18:04.659871-08:00","updated_at":"2025-11-30T18:52:22.276741-08:00","closed_at":"2025-11-30T18:52:22.276741-08:00","close_reason":"Completed - Created efrit-event.el module with EIEIO class hierarchy for all event types (session-start/end, tool-start/result, text, injection). Replaced efrit-progress--format-event to use event objects. Added 22 passing tests."}
{"id":"ef-emc","title":"efrit-chat: Add tool to create and edit buffers","description":"The chat interface currently has tools for eval_sexp, get_context, read_image, and resolve_path, but lacks a high-level tool for common tasks like:\n- Creating new buffers with specific content\n- Editing/modifying existing file buffers\n- Writing text to specific locations in buffers\n\nWhile eval_sexp can do these things via Elisp, a higher-level abstraction would make Claude more naturally conversational and less likely to write complex elisp code when simpler operations would suffice.\n\nExample interaction user might expect:\n  User: \\\"Create a new buffer called *notes* with some todo items\\\"\n  Claude: [uses buffer creation tool rather than eval_sexp with complex elisp]\"","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-11-30T17:14:14.331793-08:00","updated_at":"2025-11-30T17:20:22.614529-08:00","closed_at":"2025-11-30T17:20:22.614529-08:00","close_reason":"Implemented buffer creation and editing tools for efrit-chat. Added create_buffer, edit_buffer, read_buffer, and buffer_info tools to both classic and streamlined chat modes."}
{"id":"ef-f0i","title":"API error: model defaults to 'efrit-config' symbol instead of model name","description":"In efrit-chat-api.el line 212, when `efrit-model` is nil, the code does:\n\n```elisp\n(model (or efrit-model (require 'efrit-config) efrit-default-model))\n```\n\nThe `require` function returns the feature symbol `'efrit-config` instead of actually loading and returning the model value. This causes the API to be called with model=\"efrit-config\", which fails with:\n\n```\nAPI error response: type=not_found_error message=model: efrit-config\n```\n\nThe fix is to change the logic to properly load the config and then get the model value.","acceptance_criteria":"API calls should use the correct model name (e.g., \"claude-sonnet-4-5-20250929\") instead of \"efrit-config\".","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-11-30T19:18:00.546577-08:00","updated_at":"2025-11-30T19:19:05.314321-08:00","closed_at":"2025-11-30T19:19:05.314321-08:00","close_reason":"Fixed by correcting model fallback logic to use efrit-default-model instead of (require 'efrit-config)"}
{"id":"ef-gcq","title":"efrit-chat: Async response handling doesn't work in batch/script mode","description":"When testing efrit-chat in batch mode or non-interactive Emacs, the async response callbacks from url-retrieve never fire. This makes programmatic testing and CI/CD integration difficult.\n\nSteps to reproduce:\n1. Run emacs --batch -l script.el where script.el calls efrit-chat and efrit-send-message\n2. Wait for expected response\n3. Response callback never fires, process exits\n\nThe issue is that batch Emacs doesn't have an event loop for handling async callbacks. Possible solutions:\n- Use sleep-for to wait in batch mode for callbacks to process\n- Detect batch mode and use synchronous requests instead\n- Document that efrit-chat is interactive-only and recommend efrit-do for batch usage\"","status":"closed","priority":3,"issue_type":"task","created_at":"2025-11-30T17:14:18.083898-08:00","updated_at":"2025-11-30T17:59:49.091825-08:00","closed_at":"2025-11-30T17:59:49.091825-08:00","close_reason":"Implemented synchronous request handling in batch mode. When noninteractive (batch mode), efrit-chat now uses url-retrieve-synchronously instead of url-retrieve, ensuring API requests complete immediately without hanging. Tests confirm: (1) batch mode requests don't hang, (2) response-in-progress flag is cleared, (3) buffer updates occur immediately."}
{"id":"ef-jb8","title":"efrit-chat: API returns 404 error on message send","description":"When using efrit-chat and sending messages, API requests fail with HTTP 404 error. This blocks interactive chat usage.\n\nSteps to reproduce:\n1. Call efrit-chat\n2. Send a message with (efrit-send-message \"...\")\nResult: HTTP 404 error (detected as (error http 404) in status plist)\nExpected: Message is sent and response is received\n\nInvestigation findings:\n- URL is correct: https://api.anthropic.com/v1/messages\n- HTTP method is correct: POST\n- Headers appear correct: x-api-key, anthropic-version, anthropic-beta, content-type\n- Request body is correct: valid JSON with model, max_tokens, temperature, messages\n- efrit-do works correctly with the same API key and configuration\n- The 404 comes from the HTTP status plist, not from Elisp error handling\n\nThe issue might be:\n- A difference in how url-retrieve is being called or configured\n- How url-request-data is being processed\n- A race condition or async handling issue\n- The actual error might not be a 404 but something else in the status tuple","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-11-30T16:52:28.358111-08:00","updated_at":"2025-11-30T17:08:23.704772-08:00","closed_at":"2025-11-30T17:08:23.704772-08:00","close_reason":"Fixed unicode escape sequence bug - was using \\\\\\\\u (4 backslashes) instead of \\\\u (2 backslashes) when encoding JSON, creating invalid JSON. Replaced manual escaping with efrit-common-escape-json-unicode in both classic and streamlined request builders."}
{"id":"ef-p2i","title":"Extract content block processing into dedicated abstraction module","description":"The content block processing in `efrit-executor.el` (lines 251-287) handles multiple content types with direct aref + gethash patterns:\n\n```elisp\n(aref content i)\n(gethash \"type\" item)\n(gethash \"text\" item)\n(gethash \"id\" item)\n(gethash \"input\" item)\n```\n\nThe code loops through vector items, extracts fields, and does type-specific processing in a large cond block. This is hard to test and extend.\n\nCreate `efrit-content-processor.el` module with:\n- `efrit-content-block` EIEIO base class (type, timestamp)\n- Subclasses:\n  - `efrit-text-block` (text) \n  - `efrit-tool-use-block` (tool-id, tool-input)\n  - `efrit-tool-result-block` (tool-use-id, content, is-error)\n- Factory function `efrit-content-block-from-hash(item)` → typed block object\n- Processor interface: `efrit-content-process-blocks(blocks session)` → result plist\n- Type-specific handlers registered in a dispatch table\n\nThis makes content processing:\n- Testable (create test blocks directly)\n- Extensible (add new block types without modifying core loop)\n- Type-safe (EIEIO validation)\n\nFiles affected: efrit-executor.el (lines 251-287, 635-652).","acceptance_criteria":"Content processing loop refactored to use EIEIO block classes and dispatch. Tests cover each block type. No behavioral changes.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T18:18:09.801532-08:00","updated_at":"2025-11-30T18:35:08.178432-08:00","closed_at":"2025-11-30T18:35:08.178432-08:00","close_reason":"Closed via update"}
{"id":"ef-v41","title":"Create unified context builder to replace ad-hoc context alist construction","description":"In `efrit-session-context.el` (lines 73-99), the `efrit-unified-context-get-for-api` function builds context alist structures with conditional metadata inclusion:\n\n```elisp\n(let ((context-messages (mapcar (lambda (msg) ...) messages)))\n  (unless (eq (length context-messages) (length messages))\n    ;; conditional inclusion logic\n    ))\n```\n\nThis pattern is fragile:\n1. Building nested alists without structure makes it hard to verify correctness\n2. Conditional logic is scattered throughout the builder\n3. Adding new context fields requires understanding the whole builder\n\nCreate `efrit-context.el` module with:\n- `efrit-api-context` EIEIO class with slots:\n  - messages (vector), metadata (hash-table), environment (hash-table), etc.\n- Builder interface using builder pattern:\n  - `(efrit-context-builder)` → builder object\n  - `(efrit-context-builder-add-messages builder messages)` → builder (for chaining)\n  - `(efrit-context-builder-add-metadata builder key value)` → builder\n  - `(efrit-context-builder-build builder)` → context object\n- Conversion: `efrit-context-to-api-format(context)` → alist for API\n- Validators: `efrit-context-valid-p(context)` → bool\n\nThis makes context building:\n- Composable (builder pattern)\n- Type-safe (EIEIO validation)\n- Extensible (add new context fields without modifying builder)\n\nFiles affected: efrit-session-context.el (lines 73-99).","acceptance_criteria":"Context building moved to builder pattern. Tests verify all context types. Context conversion tested. No behavioral changes.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-30T18:18:30.766607-08:00","updated_at":"2025-11-30T18:41:56.101441-08:00","closed_at":"2025-11-30T18:41:56.101441-08:00","close_reason":"Created EIEIO-based context builder with full test coverage"}
{"id":"ef-z8d","title":"efrit-chat: No error recovery or rate limiting display","description":"When API errors occur (rate limiting, timeouts, invalid requests), efrit-chat currently just shows a generic \\\"API Error\\\" message with no guidance on:\n- Whether the error is temporary (retry) vs permanent (fix request)\n- How long to wait for rate limiting\n- What went wrong with the request body\n\nBetter UX would show:\n- Error classification (rate limit vs auth vs bad request)\n- Suggested actions (\\\"wait 30 seconds then retry\\\" vs \\\"check your API key\\\")\n- Details about what was being sent when error occurred\n- Automatic retry with exponential backoff for rate limit errors\"","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-11-30T17:14:27.539407-08:00","updated_at":"2025-11-30T18:01:17.114969-08:00","closed_at":"2025-11-30T18:01:17.114969-08:00","close_reason":"Implemented comprehensive error recovery and classification. Added efrit--classify-error function that categorizes errors (rate-limit, auth-error, permission-error, bad-request, server-error, network-error). Enhanced efrit--handle-http-error to display: (1) error type classification with emoji indicator, (2) detailed error message, (3) context-specific recommendation, (4) actionable options. Also updated efrit--parse-api-response to detect API error objects in JSON responses and throw classified errors. Tests confirm all error types are correctly classified and displayed with helpful guidance."}
{"id":"ef-zem","title":"efrit-chat-maybe-restore prompts for input in batch mode","description":"The `efrit-chat-maybe-restore` function calls `yes-or-no-p` which attempts to read from stdin in batch/noninteractive mode. This causes the following error:\n\n```\nRestore previous chat? (19 hrs ago, 4 msgs) (yes or no)\ndebug-early-backtrace...done\nEnd of file during parsing: Error reading from stdin\n```\n\nThis prevents efrit-chat from being used in batch scripts or automated testing. The fix is to check `noninteractive` and skip the prompt in batch mode.","acceptance_criteria":"When running efrit-chat in batch mode (emacs --batch), it should not prompt for input. Instead, it should either skip restoration or apply a default behavior (no restore) without user interaction.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-30T19:17:32.284749-08:00","updated_at":"2025-11-30T19:17:32.284749-08:00"}
