{"id":"ef-1lu","title":"Chat advertises full efrit-do tools but only implements 7 - returns \"Unknown tool\" errors","description":"CRITICAL FOR PRODUCTION:\n\nefrit-chat-api.el sends the full efrit-do tool schema to Claude:\n(\"tools\" . ,(efrit-do--get-current-tools-schema))\n\nBut the actual tool handlers only support 7 tools:\n1. eval_sexp\n2. get_context\n3. read_image\n4. create_buffer\n5. edit_buffer\n6. read_buffer\n7. buffer_info\n\nAll other tools (project_files, search_content, read_file, edit_file, create_file, vcs_*, checkpoints, etc.) will return \"Error: Unknown tool\" when Claude tries to use them.\n\nThis creates terrible UX where:\n1. Claude *believes* it can call 30+ tools in chat\n2. Most calls fail with confusing errors\n3. Users burn tokens on retries\n\nFIX OPTIONS:\nA) Delegate unknown tools to efrit-do--dispatch-tool (simple path)\nB) Restrict chat schema to only the 7 implemented tools (fast fix)\nC) Full unification of tool execution between chat and efrit-do","acceptance_criteria":"1. efrit-chat either supports all advertised tools OR only advertises tools it can execute\n2. No \"Unknown tool\" errors when using efrit-chat with tools in the schema","status":"in_progress","priority":0,"issue_type":"bug","created_at":"2025-12-02T21:47:44.985623-08:00","updated_at":"2025-12-02T21:51:04.401239-08:00"}
{"id":"ef-1s7","title":"Verify efrit-chat has same tool access as efrit-do","description":"User requirement: efrit-chat should have access to all the same tools as efrit-do for quick one-off tasks.\n\nCurrent status:\n- efrit-do has 34 tools via efrit-do-schema.el\n- efrit-chat uses its own tool definitions (need to verify if same)\n- Need to confirm parity and identify any gaps\n\nKey questions:\n1. Does efrit-chat send the same tool schema to Claude?\n2. Are all tools like eval_sexp, shell_exec, todo_write available in chat?\n3. Any tools in efrit-do missing from efrit-chat?\n4. Any tools in efrit-chat missing from efrit-do (that shouldn't be)?","acceptance_criteria":"Document which tools are available in both systems, identify any tool gaps, and ensure feature parity for one-off tasks","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:40.938928-08:00","updated_at":"2025-12-02T18:14:55.124961-08:00","closed_at":"2025-12-02T18:14:55.124961-08:00"}
{"id":"ef-2ia","title":"Standardize parameter naming (issue-id vs issue_id) in beads tools","description":"Inconsistent parameter naming between elisp (issue-id with hyphen) and JSON schemas (issue_id with underscore). Pick one convention and apply consistently.","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:08:47.150312-08:00","updated_at":"2025-12-02T21:34:00.327795-08:00","closed_at":"2025-12-02T21:34:00.327795-08:00"}
{"id":"ef-3pw","title":"Verify error handling and recovery in efrit-do async","description":"User requirement: Error handling must be solid for prime-time release.\n\nAreas to test:\n1. API errors (timeout, rate limit, auth failure) - should not crash, should show clear error\n2. Tool execution errors (bad elisp syntax, command not found) - should be caught and reported\n3. Circuit breaker trips - should show reason and allow recovery\n4. Session interruption (C-g) - should cleanup gracefully\n5. Recovery from errors - can Claude recover or does session need restart?\n\nCurrent implementation:\n- efrit-do--extract-error-info exists for error detection\n- efrit-do--build-error-context exists for context\n- Circuit breaker configured with limits\n- But integration testing needed\n\nTesting needed:\n1. Test bad elisp: (eval_sexp \"invalid lisp\")\n2. Test missing command: (shell_exec \"nonexistent_command\")\n3. Test timeout behavior\n4. Test session interruption\n5. Test recovery from transient errors","acceptance_criteria":"All error scenarios handled gracefully without crashing Emacs. Errors should be clearly displayed in progress buffer. Session should be recoverable or cleanly terminated.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:45.578341-08:00","updated_at":"2025-12-02T20:53:34.563982-08:00","closed_at":"2025-12-02T20:53:34.563982-08:00"}
{"id":"ef-574","title":"Update README: version mismatch and incomplete tool table","description":"README is out of date:\n\n1. Version shows 0.4.0, code is at 0.4.1\n2. Advertises \"15+ tools\" but efrit-do-schema.el defines ~34 tools\n3. Missing tool categories: todo_write, get_diagnostics, beads_*, checkpoint/restore, show_diff_preview, read_image, format_file, undo_edit","acceptance_criteria":"1. Version updated to 0.4.1 everywhere\n2. Tool table expanded to show all major categories","status":"open","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:47:45.019345-08:00","updated_at":"2025-12-02T21:47:45.019345-08:00"}
{"id":"ef-5t5","title":"Add Claude Code migration guide for Emacs users","description":"For users coming from Claude Code, there's no guide mapping concepts:\n\nClaude Code → Efrit equivalent:\n- Chat sidebar → efrit-chat (limited) or efrit-do (full)\n- Project tools → efrit-do tools (not in chat currently)\n- Diff preview → show_diff_preview tool\n- Agent view → efrit-agent buffer\n- Progress view → Efrit Progress buffer\n- AI-to-AI → Remote queue (MCP)\n\nShould also note what's not yet available.","acceptance_criteria":"Documentation exists mapping Claude Code concepts to Efrit equivalents","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-02T21:47:45.05794-08:00","updated_at":"2025-12-02T21:47:45.05794-08:00"}
{"id":"ef-8o0","title":"Potential timer leak in file watcher callbacks (efrit-remote-queue.el)","description":"In efrit-remote-queue.el line 526, each file system event creates a fire-and-forget timer with run-at-time. Under heavy file I/O or rapid file writes, this could accumulate timer objects that are never tracked or explicitly canceled.\n\nThe timer pattern:\n```\n(run-at-time 0.1 nil #'efrit-remote-queue--process-file file-path)\n```\n\nThis is a one-shot timer (interval=nil), but:\n1. Not tracked in any hash table or variable\n2. Called from a file watcher callback that fires on every file event\n3. Could accumulate hundreds of timers if files are written rapidly\n\nPotential solutions:\n1. Add a debounce mechanism to prevent multiple timers for the same file\n2. Use a timer tracking hash table like async-loop uses\n3. Add a maximum pending timers guard\n\nNote: Low risk since each timer is one-shot, but could affect performance under heavy load.","acceptance_criteria":"When file watcher is under heavy load (100+ files written quickly), verify that pending timers don't accumulate beyond a reasonable threshold (max ~20-30 pending).","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T18:08:31.280075-08:00","updated_at":"2025-12-02T20:55:59.383112-08:00","closed_at":"2025-12-02T20:55:59.383112-08:00"}
{"id":"ef-dbe","title":"Add SECURITY.md documenting trust model and Elisp execution risks","description":"Efrit is effectively \"remote code execution in Emacs\" but this isn't clearly documented.\n\nNeed a SECURITY.md (or README section) covering:\n1. Trust model - Efrit trusts Claude/Anthropic with running arbitrary Elisp\n2. What context is sent (user-login-name, home-directory, recent-files, etc.)\n3. Recommended practices (don't run as root, audit shell whitelist, etc.)\n4. Shell command security and remote access implications","acceptance_criteria":"1. SECURITY.md exists with comprehensive coverage\n2. README links to it prominently","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:47:45.039105-08:00","updated_at":"2025-12-02T21:47:45.039105-08:00"}
{"id":"ef-dcm","title":"Accept cwd parameter in MCP server beads_command tool","description":"The beads_command tool in mcp/src/server.ts should accept an optional cwd parameter to specify the working directory for bd commands.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:08:47.210928-08:00","updated_at":"2025-12-02T21:37:50.101945-08:00","closed_at":"2025-12-02T21:37:50.101945-08:00"}
{"id":"ef-e3b","title":"Progress buffer appears automatically in efrit-do async - verify this is working","description":"User requirement: The efrit-do working buffer (progress buffer) should automatically appear when efrit-do starts asynchronous execution.\n\nCurrent code shows:\n- efrit-do-async-show-progress-buffer is set to t\n- efrit-do-async-loop is called with show-progress enabled\n- But this hasn't been manually tested\n\nNeed to:\n1. Verify progress buffer auto-displays when running efrit-do (interactive test)\n2. Verify it can be hidden with efrit-do-silently\n3. Verify it can be shown manually with efrit-do-show-progress\n4. Check that window management works correctly (doesn't break existing layout)","acceptance_criteria":"1. Run efrit-do with a test command, verify progress buffer appears automatically without manual action\n2. Run efrit-do-silently, verify no progress buffer appears\n3. Run efrit-do-show-progress, verify it displays the progress buffer\n4. Verify Emacs window layout is reasonable (doesn't delete user's existing windows)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:35.397107-08:00","updated_at":"2025-12-02T20:52:55.560788-08:00","closed_at":"2025-12-02T20:52:55.560788-08:00"}
{"id":"ef-i2q","title":"Document when to use efrit-chat vs efrit-do vs efrit-agent","description":"Users (especially those from Claude Code) will be confused about which mode to use:\n\n1. efrit-chat - Multi-turn conversation, buffer-centric tools only\n2. efrit-do - Agentic command execution, full project/file tool suite\n3. efrit-agent - Structured session view for efrit-do\n\nREADME currently doesn't clearly explain:\n- Chat has much smaller tool surface than efrit-do\n- Project-wide refactor/fix workflows should use efrit-do\n- The agent buffer exists and how to use it\n\nThe efrit-agent buffer is one of the nicest parts of Efrit but is never mentioned in README!","acceptance_criteria":"1. README has clear \"When to use\" section explaining each mode\n2. efrit-agent mentioned in Features and Usage sections\n3. Help text improved to guide users to correct mode","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-02T21:47:45.009469-08:00","updated_at":"2025-12-02T21:47:45.009469-08:00"}
{"id":"ef-mch","title":"Elisp eval is unbounded - can hang Emacs with no timeout","description":"efrit-tools-eval-sexp has no timeout or sandbox around Elisp evaluation. A single misgenerated form (infinite while loop, tight recursion, blocking I/O) can freeze Emacs until user hits C-g.\n\nThis is acceptable for advanced users who understand the risk, but:\n1. README doesn't prominently document this risk\n2. No opt-in timeout mechanism exists\n3. No mention of efrit-tools-sexp-evaluation-enabled config option\n\nSUGGESTED FIX:\nAdd optional timeout wrapping with efrit-tools-eval-timeout custom variable.","acceptance_criteria":"1. Configurable timeout for eval_sexp (default on, reasonable value like 30s)\n2. Document the risk in README's security section\n3. Document efrit-tools-sexp-evaluation-enabled as a safety switch","status":"open","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:47:44.999174-08:00","updated_at":"2025-12-02T21:47:44.999174-08:00"}
{"id":"ef-phj","title":"Use shell-quote-argument in efrit-tool-beads.el for safer shell command construction","description":"Security fix: The beads tool functions should use shell-quote-argument when constructing shell commands to prevent injection vulnerabilities.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:08:47.089095-08:00","updated_at":"2025-12-02T21:09:43.087879-08:00","closed_at":"2025-12-02T21:09:43.087879-08:00"}
{"id":"ef-t57","title":"Chat mode lacks circuit breaker - only bounded by efrit-max-turns","description":"efrit-do has robust circuit breaker with max-tool-calls-per-session and error-loop detection.\n\nefrit-chat only has efrit-max-turns (default 2) and retry-on-error logic.\n\nIf chat tools keep failing, the model can burn tokens retrying with no per-tool loop detection.\n\nLower priority since max-turns provides some protection.","acceptance_criteria":"Either: add lightweight tool-call tracking to chat, OR document that only efrit-do has circuit breaker semantics","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-02T21:47:45.048556-08:00","updated_at":"2025-12-02T21:47:45.048556-08:00"}
{"id":"ef-uso","title":"Check for resource leaks in async execution loop","description":"User requirement: No resource leaks before release.\n\nAreas to audit:\n1. Buffer cleanup - are temporary buffers closed after sessions end?\n2. Timer cleanup - are all timers canceled when sessions end?\n3. Hash table cleanup - are session loops removed from tracking?\n4. HTTP connections - are URL requests properly closed?\n5. File handles - are any files left open after operations?\n\nCurrent code analysis shows:\n- efrit-do-async-loop.el properly cleans up via remhash (line 350)\n- Progress buffers may accumulate if many sessions run\n- One-shot timers in callbacks aren't tracked (efrit-do.el:1188, efrit-remote-queue.el:526)\n- Need to verify real cleanup under heavy load\n\nTesting needed:\n1. Run 10+ sequential efrit-do commands, check buffer count\n2. Monitor timer objects with (timer-list)\n3. Check for orphaned processes\n4. Stress test with concurrent commands and queueing\n5. Check memory growth over time","acceptance_criteria":"After running 10+ commands in quick succession, verify: no accumulation of buffers, no orphaned timers, no memory growth, no file descriptor leaks","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T18:08:50.308795-08:00","updated_at":"2025-12-02T20:56:50.945684-08:00","closed_at":"2025-12-02T20:56:50.945684-08:00"}
{"id":"ef-xmw","title":"CRITICAL: efrit-chat and efrit-do have very different tool sets - NOT feature parity","description":"CRITICAL ISSUE: efrit-chat only has 8 basic tools while efrit-do has 34 comprehensive tools.\n\nefrit-chat tools (hardcoded in efrit-chat-api.el lines 222-304):\n1. eval_sexp\n2. get_context\n3. resolve_path\n4. read_image\n5. create_buffer\n6. edit_buffer\n7. read_buffer\n8. buffer_info\n\nefrit-do tools (via efrit-do-schema.el):\n- All 8 chat tools PLUS\n- shell_exec\n- todo_write\n- session_complete\n- glob_files\n- request_user_input\n- confirm_action\n- checkpoint/restore\n- show_diff_preview\n- web_search\n- fetch_url\n- project_files\n- search_content\n- read_file\n- edit_file\n- create_file\n- file_info\n- vcs_status/diff/log/blame\n- elisp_docs\n- set_project_root\n- get_diagnostics\n- format_file\n- undo_edit\n- display_in_buffer\n- format_file_list\n- format_todo_list\n\nThis breaks the user requirement that efrit-chat should have access to all the same tools as efrit-do.\n\nBlocker for release until resolved.","acceptance_criteria":"efrit-chat must have access to all 34 tools available in efrit-do, OR the user must be clearly informed that efrit-chat is intentionally limited (not recommended for one-off tasks that need file operations)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T18:09:00.3812-08:00","updated_at":"2025-12-02T18:14:46.073883-08:00","closed_at":"2025-12-02T18:14:46.073883-08:00"}
{"id":"ef-xx4","title":"Shell security: ssh/scp/rsync allowed by default - document remote host risk","description":"efrit-do-allowed-shell-commands includes ssh, scp, and rsync by default.\n\nThis means Claude can connect to any host in user's SSH config, copy files to/from remote systems, and execute commands on remote systems.\n\nThe shell security section in README doesn't highlight this remote-host risk.\n\nOPTIONS:\nA) Remove ssh/scp/rsync from default whitelist\nB) Add prominent documentation warning\nC) Add separate remote access tool category","acceptance_criteria":"1. Either: ssh/scp/rsync removed from defaults, OR clear documentation about remote access implications\n2. Warning when using (\"*\") or disabling security","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-02T21:47:45.029476-08:00","updated_at":"2025-12-02T21:47:45.029476-08:00"}
{"id":"ef-zsd","title":"Add Beads MCP tool to Efrit","description":"Give Efrit access to beads CLI through MCP server. This allows Efrit to:\n- Check ready work (bd ready)\n- Create issues (bd create)\n- Update issue status (bd update)\n- Close issues (bd close)\n- List and query issues (bd list)\n- Inspect dependencies (bd show)\n\nShould be implemented as an MCP tool in the TypeScript/Node MCP server.","acceptance_criteria":"Efrit can execute beads commands through MCP and receive structured results. At minimum: bd ready, bd create, bd update, bd close, bd list","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T18:27:05.1739-08:00","updated_at":"2025-12-02T20:55:12.528625-08:00","closed_at":"2025-12-02T20:55:12.528625-08:00"}
