{"id":"ef-0le","title":"Add multi-modal display support in chat buffer","description":"Display images inline in the chat buffer when efrit creates or references them.\n\n**Use cases:**\n1. Claude generates a diagram/chart description â†’ render as image\n2. Claude reads an image file â†’ show thumbnail in chat\n3. Claude creates SVG/ASCII art â†’ display appropriately\n\n**Implementation:**\n1. Detect image references in Claude's responses\n2. For file paths: insert-image with create-image\n3. For base64 data: decode and display\n4. For ASCII art: use fixed-width font region\n\n**Technical details:**\n- Use Emacs image support (PNG, JPEG, GIF, SVG)\n- Check (display-graphic-p) for GUI vs terminal\n- Terminal fallback: show [Image: path] link\n- Respect image size limits (scale large images)\n\n**Edge cases:**\n- Terminal Emacs (no image support) - show path/link instead\n- Very large images - scale to fit window width\n- Animated GIFs - display first frame or animate?\n- Missing image files - show placeholder\n- Remote images (URLs) - fetch and cache?\n\n**Dependencies:** None, but benefits from ef-wu6 (consolidation) first.\n\n**Acceptance criteria:**\n- Images from read_image tool display inline\n- Images scale to reasonable size\n- Terminal mode shows useful fallback\n- No crashes on missing/corrupt images","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-29T10:08:58.056669-08:00","updated_at":"2025-11-29T10:26:14.142999-08:00"}
{"id":"ef-1qc","title":"No HTTP error handling in streamlined mode","description":"efrit-streamlined--handle-response doesn't check status parameter for HTTP errors before parsing\n\n**Note:** This bug is in streamlined mode only. If ef-wu6 (consolidation) is completed, this issue becomes moot and should be closed.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-29T10:07:05.999936-08:00","updated_at":"2025-11-29T10:28:02.627757-08:00"}
{"id":"ef-2a6","title":"Implement chat history persistence","description":"Save and restore efrit-chat conversations, similar to efrit-do transcript support.\n\n**Current state:**\n- efrit-do has full transcript support (efrit-session-transcript.el)\n- efrit-chat conversations are lost when buffer is killed\n- No way to resume a chat conversation\n\n**Implementation (adapt from efrit-session-transcript.el):**\n\n1. **Auto-save:**\n   - Save after each exchange (user message + response)\n   - Store in ~/.emacs.d/.efrit/chat-transcripts/\n   - Filename: chat-{timestamp}.json\n\n2. **Data format:**\n   ```json\n   {\n     \"id\": \"chat-20251129-103000\",\n     \"created_at\": \"2025-11-29T10:30:00Z\",\n     \"updated_at\": \"...\",\n     \"messages\": [...],\n     \"message_count\": 10,\n     \"snippet\": \"First user message preview...\",\n     \"model\": \"claude-sonnet-4\"\n   }\n   ```\n\n3. **Commands:**\n   - efrit-chat-list-sessions - browse saved chats\n   - efrit-chat-resume - resume a previous chat\n   - efrit-chat-export - export to markdown\n   - efrit-chat-delete-session - remove old chat\n\n4. **Integration:**\n   - Hook into efrit--display-message to trigger saves\n   - Add to efrit-chat-mode setup\n\n**Edge cases:**\n- Very long conversations (\u003e1MB) - warn, maybe compress\n- Rapid messages (debounce saves)\n- Corrupt transcript file - skip with warning\n- Resume with different model - warn user\n- Buffer killed without clean shutdown - rely on auto-save\n\n**Dependencies:**\n- ef-wu6 (consolidation) - easier to implement for single mode\n\n**Acceptance criteria:**\n- Conversations auto-save after each exchange\n- efrit-chat-list-sessions shows recent chats\n- Can resume conversation with full history\n- Export produces readable markdown","status":"open","priority":1,"issue_type":"feature","created_at":"2025-11-29T10:08:45.261078-08:00","updated_at":"2025-11-29T10:27:54.932729-08:00","dependencies":[{"issue_id":"ef-2a6","depends_on_id":"ef-wu6","type":"blocks","created_at":"2025-11-29T10:27:02.310819-08:00","created_by":"daemon"}]}
{"id":"ef-3en","title":"Create efrit-console for admin and debugging","description":"Create a developer console buffer for monitoring and debugging efrit.\n\n**Buffer:** *efrit-console*\n\n**Sections:**\n\n1. **Live Activity**\n   - Real-time log of API requests/responses (summary, not full)\n   - Tool executions with timing\n   - Errors with stack traces\n\n2. **Session Info**\n   - Current session ID\n   - Active conversations (chat, do)\n   - Memory usage\n\n3. **Configuration**\n   - Current model and settings\n   - API endpoint\n   - Feature flags\n   - Hook status\n\n4. **Performance**\n   - Average response time\n   - Token throughput\n   - Error rate\n\n**Implementation:**\n1. Create ring buffer for log entries (limit size)\n2. Hook into key functions to log events\n3. Use efrit-log infrastructure for consistency\n4. Auto-refresh display (timer)\n\n**Commands:**\n- M-x efrit-console - open console\n- M-x efrit-console-clear - clear log\n- In console: g=refresh, c=clear, q=quit\n\n**Log levels:**\n- Debug (verbose, off by default)\n- Info (normal operations)\n- Warn (recoverable issues)\n- Error (failures)\n\n**Edge cases:**\n- Very high log volume - use ring buffer, drop old\n- Console closed during operation - reopen shows recent\n- Multiple frames - console is global\n\n**Acceptance criteria:**\n- Console shows recent activity\n- Errors are prominently displayed\n- Can filter by log level\n- Doesn't impact performance significantly","status":"open","priority":3,"issue_type":"feature","created_at":"2025-11-29T10:08:58.099765-08:00","updated_at":"2025-11-29T10:27:54.962648-08:00"}
{"id":"ef-asy","title":"Add usage tracking and session metrics dashboard","description":"Create a dashboard buffer (*efrit-dashboard*) showing session metrics and usage.\n\n**Dashboard sections:**\n\n1. **Current Session**\n   - Session ID, start time, duration\n   - Commands executed, API calls made\n   - Token usage (input/output/total)\n   - Estimated cost\n\n2. **Tool Usage**\n   - Table of tools used with counts\n   - Success/failure rates per tool\n\n3. **History** \n   - Recent sessions list\n   - Quick resume links\n\n4. **Configuration**\n   - Current model\n   - API endpoint\n   - Feature flags\n\n**Implementation:**\n1. Create efrit-dashboard-mode (derived from special-mode)\n2. Use tabulated-list-mode for tables\n3. Auto-refresh timer (configurable)\n4. Keybindings: g=refresh, q=quit, RET=view session\n\n**Commands:**\n- M-x efrit-dashboard - open dashboard\n- M-x efrit-dashboard-refresh - refresh data\n\n**Dependencies:** \n- ef-jq2 (token tracking) for usage data\n\n**Edge cases:**\n- No active session - show 'No session' state\n- Very long session list - paginate or limit\n- Metrics tracking disabled - show warning\n\n**Acceptance criteria:**\n- Dashboard opens with M-x efrit-dashboard\n- Shows current session metrics\n- Auto-refreshes every 30s (configurable)\n- Can navigate to session transcripts","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-29T10:08:45.301008-08:00","updated_at":"2025-11-29T10:26:27.816965-08:00","dependencies":[{"issue_id":"ef-asy","depends_on_id":"ef-jq2","type":"blocks","created_at":"2025-11-29T10:26:27.792062-08:00","created_by":"daemon"}]}
{"id":"ef-ay5","title":"Add conversation context window indicator","description":"Show context window usage in chat buffer header or mode line.\n\n**Display format:**\n- Mode line: [Context: 45K/200K (22%)]\n- Or header line in chat buffer\n- Color coding: green (\u003c50%), yellow (50-80%), red (\u003e80%)\n\n**What to track:**\n- Approximate tokens in conversation history\n- System prompt size\n- Tool definitions size\n- Remaining context window for model\n\n**Implementation:**\n1. Calculate message token count (rough: chars/4)\n2. Add to running total as messages are added\n3. Update mode-line-format or header-line-format\n4. Warn when approaching limit (configurable threshold)\n\n**Model context limits:**\n- claude-sonnet-4: 200K tokens\n- claude-opus-4: 200K tokens\n- (Make configurable per model)\n\n**Edge cases:**\n- Token count is approximate (chars/4 is rough)\n- Images count differently (fixed token cost)\n- Tool results vary widely in size\n- Context window changes if model changes\n\n**Acceptance criteria:**\n- Indicator visible in chat buffer\n- Updates after each message\n- Warning at 80% threshold\n- Accurate within 10% of actual tokens\n\n**Dependencies:** ef-jq2 for accurate token tracking","status":"open","priority":3,"issue_type":"feature","created_at":"2025-11-29T10:08:58.00939-08:00","updated_at":"2025-11-29T10:26:49.313876-08:00","dependencies":[{"issue_id":"ef-ay5","depends_on_id":"ef-jq2","type":"blocks","created_at":"2025-11-29T10:26:27.838679-08:00","created_by":"daemon"}]}
{"id":"ef-bcn","title":"efrit-do used cl-return-from without cl-block wrapper","description":"During dogfooding, efrit-do generated elisp code that used cl-return-from without wrapping the function in cl-block, which would cause a runtime error.\n\n**Root cause:** Claude doesn't always generate valid elisp, especially for less common constructs.\n\n**Potential solutions:**\n\n1. **System prompt improvement:**\n   Add elisp-specific guidance to efrit-tools-system-prompt:\n   - 'When using cl-return-from, ensure function is wrapped in cl-block'\n   - 'Prefer simple control flow (if/when/cond) over cl-lib macros'\n   - 'Test elisp mentally before outputting'\n\n2. **Validation layer:**\n   Before executing elisp from Claude:\n   - Parse with read (catches syntax errors)\n   - Check for known problematic patterns\n   - Optionally byte-compile to catch warnings\n\n3. **Sandboxed test execution:**\n   Run in condition-case, report errors back to Claude for self-correction\n\n**Recommendation:** Start with system prompt improvements (cheapest), add validation if problems persist.\n\n**Edge cases:**\n- Valid but unusual code patterns\n- Code that only fails at runtime (not parse time)\n- Macros that expand incorrectly\n\n**Acceptance criteria:**\n- cl-return-from without cl-block is flagged or prevented\n- Common elisp mistakes caught before execution\n- Errors reported clearly for debugging","status":"open","priority":2,"issue_type":"bug","created_at":"2025-11-29T10:08:31.280707-08:00","updated_at":"2025-11-29T10:27:02.336467-08:00"}
{"id":"ef-bg7","title":"Logic bug in streamlined continuation decision","description":"claude-signals-done incorrectly includes (and tool-uses (not has-text-content)) which prevents tool-only responses from continuing\n\n**Note:** This bug is in streamlined mode only. If ef-wu6 (consolidation) is completed, this issue becomes moot and should be closed.","status":"open","priority":2,"issue_type":"bug","created_at":"2025-11-29T10:07:06.034679-08:00","updated_at":"2025-11-29T10:28:02.718176-08:00"}
{"id":"ef-cnh","title":"Update efrit-chat.el commentary section","description":"Commentary section is incomplete. Needs: 1) Remove confusing self-reference about consolidation, 2) Add usage examples, 3) Describe key features and capabilities, 4) Explain difference between classic and streamlined modes, 5) Add info about dependencies.","status":"open","priority":4,"issue_type":"task","created_at":"2025-11-29T10:11:18.761523-08:00","updated_at":"2025-11-29T10:11:18.761523-08:00","dependencies":[{"issue_id":"ef-cnh","depends_on_id":"ef-wu6","type":"blocks","created_at":"2025-11-29T10:27:02.360135-08:00","created_by":"daemon"}]}
{"id":"ef-ea0","title":"Streamlined chat doesn't show response when tool returns buffer object","description":"When a tool call returns a buffer object (e.g., #\u003cbuffer *haiku*\u003e), the streamlined chat mode doesn't display any response to the user.\n\n**Root Cause:** In efrit-streamlined--handle-response, when claude-signals-done is true because of (and tool-uses (not has-text-content)), it finishes without calling efrit-streamlined--display-response.\n\n**Steps to reproduce:**\n1. Use efrit-streamlined-send\n2. Ask: 'Create a buffer called *test* with hello world'\n3. Buffer is created but chat shows no confirmation\n\n**Expected:** Should display a message like 'Done' or 'Created buffer *test*'\n\n**Note:** This bug is in streamlined mode only. If ef-wu6 (consolidation) is done first, this becomes moot.","status":"open","priority":2,"issue_type":"bug","created_at":"2025-11-29T10:04:44.102142-08:00","updated_at":"2025-11-29T10:25:25.522695-08:00"}
{"id":"ef-f9s","title":"Missing HTTP response buffer cleanup in streamlined mode","description":"efrit-streamlined--handle-response doesn't clean up the HTTP response buffer, causing memory leaks\n\n**Note:** This bug is in streamlined mode only. If ef-wu6 (consolidation) is completed, this issue becomes moot and should be closed.","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-29T10:07:05.970427-08:00","updated_at":"2025-11-29T10:28:02.585195-08:00"}
{"id":"ef-fal","title":"Add conversation branching support","description":"Allow conversation branching: go back to earlier point and take a different path.\n\n**Concept:**\nLike git branches for conversations. User can:\n1. Go back to message N\n2. Send a different follow-up\n3. Both branches are preserved\n4. Can switch between branches\n\n**Data model:**\n- Conversation is a tree, not a list\n- Each message has: id, parent_id, content, timestamp\n- Branch = path from root to leaf\n- Current branch = active path\n\n**UI:**\n- Show branch indicator: [Branch: main] or [Branch: alt-1]  \n- Command to list branches\n- Command to switch branches\n- Command to create branch from current message\n- Visual tree view (optional, complex)\n\n**Commands:**\n- /branch [name] - create branch from current point\n- /branches - list all branches\n- /switch \u003cname\u003e - switch to branch\n- /history - show current branch history\n\n**Implementation complexity:** HIGH\n- Need to refactor message storage (list â†’ tree)\n- Chat buffer display needs to handle branches\n- API context needs correct ancestor chain\n- Transcript persistence needs tree format\n\n**Recommendation:** \nThis is a v2 feature. Defer until core chat is solid.\nConsider simpler alternative: /snapshot to save current state, /restore to go back.\n\n**Dependencies:** \n- ef-wu6 (consolidation) - much easier with single code path\n- ef-2a6 (chat history) - need persistence first\n\n**Edge cases:**\n- Deep branch (many levels)\n- Merging branches (probably don't support)\n- Branch from branch\n- Deleting a branch with children\n\n**Acceptance criteria (if implemented):**\n- Can create named branch from any point\n- Can switch between branches\n- Both branches have correct context\n- Branches persist across sessions","status":"open","priority":4,"issue_type":"feature","created_at":"2025-11-29T10:08:58.13559-08:00","updated_at":"2025-11-29T10:27:30.143973-08:00","dependencies":[{"issue_id":"ef-fal","depends_on_id":"ef-wu6","type":"blocks","created_at":"2025-11-29T10:27:54.883608-08:00","created_by":"daemon"},{"issue_id":"ef-fal","depends_on_id":"ef-2a6","type":"blocks","created_at":"2025-11-29T10:27:54.907683-08:00","created_by":"daemon"}]}
{"id":"ef-iwd","title":"Add retry and error recovery UX","description":"Improve error handling UX so errors don't disrupt conversation flow.\n\n**Current behavior:**\n- API errors dump a message and leave user at prompt\n- No easy way to retry\n- Error details may be lost\n\n**Improved UX:**\n\n1. **Inline error display:**\n   Show error in chat as a collapsible section:\n   ```\n   [Error: API rate limited. Retrying in 5s... (click to expand)]\n   ```\n\n2. **Automatic retry with backoff:**\n   - Retry transient errors (429, 500, 503, network)\n   - Exponential backoff: 1s, 2s, 4s, 8s, max 30s\n   - Max 3 retries, then show permanent error\n\n3. **Manual retry:**\n   - efrit-retry (bound to some key in chat mode)\n   - /retry slash command\n   - Retry button in error message (if using widgets)\n\n4. **Error categories:**\n   - Transient (retry automatically): rate limit, server error, network\n   - Permanent (show and stop): auth error, invalid request, context too long\n   - Recoverable (suggest action): context too long â†’ offer to summarize\n\n**Implementation:**\n1. Wrap API calls in retry logic\n2. Store last request for manual retry\n3. Parse error responses for category\n4. Update chat buffer with retry status\n\n**Edge cases:**\n- Retry during rate limit makes it worse - respect Retry-After header\n- Network comes back mid-retry\n- User sends new message during retry - cancel retry, send new\n- Partial response before error (streaming)\n\n**Acceptance criteria:**\n- Transient errors retry automatically (up to 3x)\n- Users can manually retry with command\n- Error messages are clear and actionable\n- Conversation can continue after error","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-29T10:08:45.415682-08:00","updated_at":"2025-11-29T10:27:30.116777-08:00"}
{"id":"ef-jq2","title":"Add token usage tracking to session metrics","description":"Track token usage from API responses to show costs and context consumption.\n\n**Anthropic API response includes:**\n```json\n{\n  \"usage\": {\n    \"input_tokens\": 1234,\n    \"output_tokens\": 567\n  }\n}\n```\n\n**Implementation:**\n1. Extract usage from every API response in efrit--handle-api-response\n2. Store in efrit-session-metrics: input_tokens, output_tokens, total_tokens\n3. Calculate cost based on model (sonnet: $3/$15 per 1M tokens)\n4. Add to session summary\n\n**New metrics to track:**\n- input_tokens_total\n- output_tokens_total  \n- estimated_cost_usd\n- tokens_per_request_avg\n\n**Storage:**\n- Add to efrit-session-metrics alist\n- Persist with session save\n\n**Edge cases:**\n- API errors (no usage in response)\n- Streaming mode (usage comes at end)\n- Cached responses (if we add caching)\n- Model changes mid-session (different rates)\n\n**Acceptance criteria:**\n- Token counts visible in session summary\n- Cumulative totals across session\n- Cost estimate in USD\n- Works for both chat and do modes","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-29T10:10:37.980802-08:00","updated_at":"2025-11-29T10:26:14.167428-08:00"}
{"id":"ef-kc6","title":"Add slash command system like Claude Code","description":"Add slash command system for quick actions in chat.\n\n**Core commands:**\n- /clear - Clear conversation (calls efrit-chat-clear)\n- /model [name] - Show or set current model\n- /help - Show available commands\n- /cost - Show token usage and estimated cost\n- /export [file] - Export conversation to markdown\n- /context - Show current context size\n- /retry - Retry last failed message\n- /undo - Remove last exchange\n\n**Implementation:**\n1. Intercept input starting with /\n2. Parse command and arguments\n3. Execute corresponding function\n4. Display result in chat\n\n**Parsing:**\n- Split on first space: command + args\n- Support quoted arguments for paths with spaces\n- Tab completion for command names\n\n**Adding new commands:**\n- Define efrit-slash-command-alist\n- Each entry: (name . function)\n- Functions receive args as string\n\n**Edge cases:**\n- Unknown command - show error + suggestions\n- Command with missing required args\n- Command that fails - show error in chat\n- / at start of normal message (escape with //)\n\n**Acceptance criteria:**\n- /help shows all commands\n- /clear works\n- /model shows current model\n- Tab completes command names\n- Unknown commands show helpful error","status":"open","priority":3,"issue_type":"feature","created_at":"2025-11-29T10:08:45.37878-08:00","updated_at":"2025-11-29T10:26:49.341133-08:00","dependencies":[{"issue_id":"ef-kc6","depends_on_id":"ef-wu6","type":"blocks","created_at":"2025-11-29T10:28:20.782512-08:00","created_by":"daemon"}]}
{"id":"ef-nan","title":"efrit-chat-clear should work from any buffer","description":"efrit-chat-clear errors with 'Not in an Efrit chat buffer' when called from a different buffer.\n\n**Current behavior:**\n```elisp\n(if (not (eq major-mode 'efrit-mode))\n    (user-error \"Not in an Efrit chat buffer\")\n  ...)\n```\n\n**Fix options:**\n\n1. **Switch to buffer and clear (recommended):**\n   ```elisp\n   (with-current-buffer (get-buffer-create efrit-buffer-name)\n     ;; clear logic here\n     )\n   ```\n\n2. **Accept optional buffer argument:**\n   ```elisp\n   (defun efrit-chat-clear (\u0026optional buffer)\n     (interactive)\n     (let ((buf (or buffer (get-buffer efrit-buffer-name))))\n       ...))\n   ```\n\n**Edge cases:**\n- Chat buffer doesn't exist yet - create it, then clear (no-op but valid)\n- Multiple chat buffers (if we support that later) - need buffer arg\n\n**Acceptance criteria:**\n- M-x efrit-chat-clear works from any buffer\n- Clears the *efrit-chat* buffer\n- Shows confirmation message","status":"open","priority":3,"issue_type":"bug","created_at":"2025-11-29T10:11:18.71562-08:00","updated_at":"2025-11-29T10:28:36.772569-08:00"}
{"id":"ef-uzk","title":"Add @-mention context inclusion like Cursor/Claude Code","description":"Support @-mentions in chat to explicitly include context, similar to Cursor and Claude Code.\n\n**Syntax:**\n- @filename - Include file contents (e.g., @efrit-chat.el)\n- @path/to/file - Include file at path\n- @symbol - Find and include function/variable definition\n- @buffer - Include contents of named buffer\n\n**Implementation:**\n1. Parse @-mentions before sending to API\n2. Resolve each mention to actual content\n3. Prepend resolved content to user message or add as system context\n4. Display resolved mentions in chat (so user knows what was included)\n\n**Resolution logic:**\n- Files: Search project root, then load-path for .el files\n- Symbols: Use find-function-noselect, describe-function\n- Buffers: Get buffer by name\n\n**Edge cases:**\n- @mention that doesn't resolve (file not found) - show warning, continue\n- Very large files - truncate with [...] indicator\n- Binary files - skip with warning\n- Circular references (file @-mentions another file)\n- Multiple @-mentions of same file - dedupe\n\n**UI considerations:**\n- Autocomplete for @-mentions (like company-mode)\n- Syntax highlighting for @-mentions in input\n- Show byte count of included context\n\n**Acceptance criteria:**\n- @efrit-chat.el includes the file\n- @efrit-send-message includes that function's definition\n- Unresolved mentions show clear error\n- Works in both efrit-chat and efrit-do","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-29T10:08:58.172877-08:00","updated_at":"2025-11-29T10:25:54.036074-08:00"}
{"id":"ef-w1e","title":"UTF-8 character encoding broken for em-dash and special chars","description":"When Claude returns text with em-dashes (â€”) or other non-ASCII Unicode characters, they display as garbled text (e.g., 'Ã¢' instead of 'â€”').\n\n**Root Cause:** The JSON escaping in efrit-chat.el (around line 460) converts Unicode to escape sequences for the request, but the response decoding doesn't properly handle UTF-8.\n\n**Observed in:** efrit-streamlined--handle-response and efrit--parse-api-response\n\n**Steps to reproduce:**\n1. Start efrit-chat\n2. Ask: 'Write a haiku with an em-dash'\n3. Observe garbled characters in output\n\n**Fix approach:**\n1. Ensure response buffer uses UTF-8 coding system\n2. Check decode-coding-string usage in response parsing\n3. Test with various Unicode: em-dash (â€”), smart quotes (), emoji (ðŸŽ‰)\n\n**Edge cases:**\n- Emoji in responses\n- CJK characters\n- Mathematical symbols\n- RTL text (Hebrew, Arabic)","status":"open","priority":1,"issue_type":"bug","created_at":"2025-11-29T10:04:44.14572-08:00","updated_at":"2025-11-29T10:25:16.053528-08:00"}
{"id":"ef-wap","title":"Add streaming response support for real-time feedback","description":"Currently responses appear all at once after the full API response is received. Add streaming support so users see text appear incrementally.\n\n**Implementation approach:**\n1. Use Anthropic's streaming API (add 'stream': true to request)\n2. Handle Server-Sent Events (SSE) format in response\n3. Parse incremental content_block_delta events\n4. Append text to chat buffer as it arrives\n5. Handle tool_use events during stream\n\n**Technical considerations:**\n- url-retrieve doesn't support streaming well; may need url-retrieve-synchronously with sentinel or switch to curl/plz.el\n- Need to handle partial JSON in stream events\n- Tool calls arrive as separate events, need to buffer and execute\n- Error events can arrive mid-stream\n\n**Edge cases:**\n- Network interruption during stream\n- Very long responses (buffer updates)\n- Tool calls interspersed with text\n- Rate limiting mid-stream\n- User wants to cancel mid-stream (need abort mechanism)\n\n**Dependencies:** Should be done after ef-wu6 (consolidation) so we only implement once.\n\n**Acceptance criteria:**\n- Text appears within 500ms of first token\n- Smooth scrolling as text appends\n- Tool results display after execution\n- Ctrl-G or similar can abort stream","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-29T10:08:45.341956-08:00","updated_at":"2025-11-29T10:25:39.804339-08:00","dependencies":[{"issue_id":"ef-wap","depends_on_id":"ef-wu6","type":"blocks","created_at":"2025-11-29T10:25:54.010245-08:00","created_by":"daemon"}]}
{"id":"ef-wu6","title":"Consolidate efrit-chat modes into single robust implementation","description":"Two chat modes exist: classic (efrit-chat/efrit-send-message) and streamlined (efrit-streamlined-send). The streamlined mode has multiple bugs (race conditions, missing cleanup, no HTTP error handling) and uses fragile global state. Classic mode is more robust.\n\nRecommendation: Keep classic mode as the single implementation, adding the useful work buffer logging from streamlined mode. Remove streamlined mode entirely.\n\nBenefits:\n- Single code path to maintain\n- Fix bugs once\n- Consistent UX\n- No race conditions from global state\n\nThe work buffer from streamlined mode (for debugging/logging) should be ported to classic mode as an optional feature.\n\nNOTE: This consolidation would resolve these streamlined-mode bugs by deleting the code:\n- ef-f9s: Missing buffer cleanup\n- ef-1qc: No HTTP error handling\n- ef-x1c: Race condition with globals\n- ef-bg7: Logic bug in continuation\n- ef-ea0: Buffer object response not shown","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-29T10:23:15.719111-08:00","updated_at":"2025-11-29T10:23:57.366212-08:00"}
{"id":"ef-x1c","title":"Race condition with global streamlined variables","description":"efrit-streamlined--current-messages and efrit-streamlined--turn-count are global vars that could cause issues with concurrent requests\n\n**Note:** This bug is in streamlined mode only. If ef-wu6 (consolidation) is completed, this issue becomes moot and should be closed.","status":"open","priority":2,"issue_type":"bug","created_at":"2025-11-29T10:07:06.069338-08:00","updated_at":"2025-11-29T10:28:02.672342-08:00"}
