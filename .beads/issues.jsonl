{"id":"ef-0pd","title":"DRY up tool handler boilerplate with macro/helper","description":"Many handlers in efrit-do-handlers.el follow identical patterns:\n\n```elisp\n(defun efrit-do--handle-FOO (tool-input)\n  (require 'efrit-tool-foo)\n  (or (efrit-do--validate-hash-table tool-input \"foo\")\n      (efrit-do--validate-required tool-input \"foo\" \"field1\")\n      (let* ((args (efrit-do--extract-fields tool-input '(\"field1\" \"field2\")))\n             (result (efrit-tool-foo args)))\n        (efrit-do--format-tool-result result \"Foo Result\"))))\n```\n\nThis is repeated for ~20 tools: web_search, fetch_url, read_file, edit_file, create_file, vcs_*, etc.\n\nCreate a macro or helper:\n\n```elisp\n(defmacro efrit-define-simple-tool-handler\n    (fn-name tool-name required-fields field-specs underlying-fn label \u0026optional require-lib)\n  ...)\n```\n\nThen replace boilerplate handlers with one-liners.\n\nFile affected:\n- lisp/interfaces/efrit-do-handlers.el (reduce from 879 to ~500 lines)","acceptance_criteria":"1. Macro defined for simple tool handlers\n2. At least 15 handlers converted to macro usage\n3. Easier to add new tools - single line per simple tool\n4. Byte-compile warnings unchanged or improved","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.240879-08:00","updated_at":"2025-12-02T23:14:18.369197-08:00","closed_at":"2025-12-02T23:14:18.369197-08:00"}
{"id":"ef-0v9","title":"Add loading spinner to efrit-chat buffer during API calls","description":"Add a visual spinner or loading indicator in the chat buffer when waiting for API responses. Users perceive the application as unresponsive during slow API calls.","acceptance_criteria":"- Spinner appears in chat buffer when API call starts\n- Spinner disappears when response arrives\n- Spinner provides visual feedback that system is working","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-03T10:45:19.32003-08:00","updated_at":"2025-12-03T10:47:18.445578-08:00","closed_at":"2025-12-03T10:47:18.445578-08:00"}
{"id":"ef-15l","title":"Unify retry \u0026 rate-limit configuration across modules","description":"Duplicate and mode-specific retry/limit knobs:\n\nChat mode:\n- efrit-max-retries\n- efrit-retry-on-errors\n\nDo mode:\n- efrit-do-max-retries\n- efrit-do-retry-on-errors\n\nTools:\n- efrit-tools-max-eval-per-session\n- efrit-tools-max-total-calls-per-session\n\nExecutor:\n- efrit-executor-max-continuations\n- efrit-executor-max-tool-calls\n- efrit-executor-session-timeout\n\nConsolidate in efrit-config.el (or new efrit-limits.el):\n- efrit-tool-max-retries (shared default: 3)\n- efrit-tool-retry-on-errors (shared default: t)\n- efrit-tool-max-calls-per-session (shared)\n- efrit-session-timeout (shared)\n\nHave each module use these shared values or bind local overrides.\n\nFiles affected:\n- lisp/core/efrit-config.el\n- lisp/core/efrit-chat-api.el\n- lisp/interfaces/efrit-do.el\n- lisp/core/efrit-tools.el\n- lisp/core/efrit-executor.el","acceptance_criteria":"1. Fewer total defcustom variables for limits/retries\n2. Consistent behavior between chat and do modes\n3. Single place to configure session safety limits","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.23098-08:00","updated_at":"2025-12-02T23:17:21.593022-08:00","closed_at":"2025-12-02T23:17:21.593022-08:00"}
{"id":"ef-1jo","title":"efrit-do fails with format error and missing tool execution function","description":"When executing `efrit-do` with command \"open the mayor dir in ~/ai\", the command fails with multiple errors:\n\n1. Format string error in logging: \"Format specifier doesn't match argument type\" - format call passes nil for %d iterations parameter\n\n2. Missing function: \"Symbol's function definition is void: efrit-do-async--execute-single-tool\" - indicates tool execution is not implemented or not exported\n\n3. API error from Claude: \"messages.1: `tool_use` ids were found without `tool_result` blocks immediately after\" - the tool_use block is not being properly followed by a tool_result block in the message continuation\n\nThis blocks basic efrit-do functionality.","acceptance_criteria":"- Format string error is fixed (handle nil iterations gracefully)\n- efrit-do-async--execute-single-tool function is implemented/exported\n- Tool execution flow properly constructs tool_result blocks for API continuations","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-03T10:51:58.269061-08:00","updated_at":"2025-12-03T10:54:47.735396-08:00","closed_at":"2025-12-03T10:54:47.735396-08:00"}
{"id":"ef-1lu","title":"Chat advertises full efrit-do tools but only implements 7 - returns \"Unknown tool\" errors","description":"CRITICAL FOR PRODUCTION:\n\nefrit-chat-api.el sends the full efrit-do tool schema to Claude:\n(\"tools\" . ,(efrit-do--get-current-tools-schema))\n\nBut the actual tool handlers only support 7 tools:\n1. eval_sexp\n2. get_context\n3. read_image\n4. create_buffer\n5. edit_buffer\n6. read_buffer\n7. buffer_info\n\nAll other tools (project_files, search_content, read_file, edit_file, create_file, vcs_*, checkpoints, etc.) will return \"Error: Unknown tool\" when Claude tries to use them.\n\nThis creates terrible UX where:\n1. Claude *believes* it can call 30+ tools in chat\n2. Most calls fail with confusing errors\n3. Users burn tokens on retries\n\nFIX OPTIONS:\nA) Delegate unknown tools to efrit-do--dispatch-tool (simple path)\nB) Restrict chat schema to only the 7 implemented tools (fast fix)\nC) Full unification of tool execution between chat and efrit-do","acceptance_criteria":"1. efrit-chat either supports all advertised tools OR only advertises tools it can execute\n2. No \"Unknown tool\" errors when using efrit-chat with tools in the schema","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-02T21:47:44.985623-08:00","updated_at":"2025-12-02T21:52:40.646183-08:00","closed_at":"2025-12-02T21:52:40.646183-08:00"}
{"id":"ef-1s7","title":"Verify efrit-chat has same tool access as efrit-do","description":"User requirement: efrit-chat should have access to all the same tools as efrit-do for quick one-off tasks.\n\nCurrent status:\n- efrit-do has 34 tools via efrit-do-schema.el\n- efrit-chat uses its own tool definitions (need to verify if same)\n- Need to confirm parity and identify any gaps\n\nKey questions:\n1. Does efrit-chat send the same tool schema to Claude?\n2. Are all tools like eval_sexp, shell_exec, todo_write available in chat?\n3. Any tools in efrit-do missing from efrit-chat?\n4. Any tools in efrit-chat missing from efrit-do (that shouldn't be)?","acceptance_criteria":"Document which tools are available in both systems, identify any tool gaps, and ensure feature parity for one-off tasks","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:40.938928-08:00","updated_at":"2025-12-02T18:14:55.124961-08:00","closed_at":"2025-12-02T18:14:55.124961-08:00"}
{"id":"ef-2c1","title":"Unify tool_result building across chat and executor","description":"Tool result packaging is duplicated and inconsistent:\n\nefrit-chat-api.el:\n- efrit--build-tool-result (handles image results and text)\n\nefrit-executor.el:\n- efrit-executor--process-sync-content builds tool_result blocks ad-hoc\n- efrit-session-build-tool-result used in async path\n\nTools return different shapes:\n- Text strings with embedded markers ([SESSION-COMPLETE: ...], [WAITING-FOR-USER])\n- JSON-encoded payloads wrapped by efrit-do--format-tool-result\n- Image results as ((image . ...)) alists\n\nCreate efrit-tool-runtime.el (or add to efrit-common.el):\n```elisp\n(defun efrit-tool-build-result-block (tool-id result \u0026optional is-error)\n  \"Return a tool_result block suitable for Anthropic's messages API.\"\n  ...)\n```\n\nUse this single function in both chat and executor paths.\n\nFiles affected:\n- lisp/core/efrit-chat-api.el (efrit--build-tool-result)\n- lisp/core/efrit-executor.el (tool_result building)\n- lisp/core/efrit-session.el (efrit-session-build-tool-result)","acceptance_criteria":"1. Single tool_result building function used everywhere\n2. Consistent handling of image, text, and error results\n3. Session-control markers documented as part of tool contract","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.250076-08:00","updated_at":"2025-12-02T23:18:30.576138-08:00","closed_at":"2025-12-02T23:18:30.576138-08:00"}
{"id":"ef-2ia","title":"Standardize parameter naming (issue-id vs issue_id) in beads tools","description":"Inconsistent parameter naming between elisp (issue-id with hyphen) and JSON schemas (issue_id with underscore). Pick one convention and apply consistently.","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:08:47.150312-08:00","updated_at":"2025-12-02T21:34:00.327795-08:00","closed_at":"2025-12-02T21:34:00.327795-08:00"}
{"id":"ef-33f","title":"Call agent buffer on session start in async loop","description":"Wire the async loop to initialize the agent buffer when a session starts.\n\nCURRENT STATE:\n- efrit-agent--create-buffer and efrit-agent--show-buffer exist (private)\n- No public efrit-agent-start-session function exists yet\n\nIMPLEMENTATION (choose one approach):\n\nAPPROACH A (Recommended - Add public wrapper):\n1. In efrit-agent.el, add a new public function after line 917:\n   (defun efrit-agent-start-session (session-id command)\n     \"Start agent buffer for SESSION-ID with COMMAND.\"\n     (efrit-agent--create-buffer session-id command)\n     (efrit-agent--show-buffer)\n     (efrit-agent-set-status 'working))\n\n2. In efrit-do-async-loop.el, after line 78:\n   (require 'efrit-agent)\n   (efrit-agent-start-session session-id (efrit-session-command session))\n\nAPPROACH B (Use private functions directly):\n1. In efrit-do-async-loop.el around line 76-78, add:\n   (require 'efrit-agent)\n   (efrit-agent--create-buffer session-id (efrit-session-command session))\n   (efrit-agent--show-buffer)\n   (efrit-agent-set-status 'working)\n\nNOTE: You'll need to check if efrit-session has a 'command' accessor. Look at efrit-session.el for the struct definition. The command might be stored differently.\n\nFILES: lisp/interfaces/efrit-agent.el, lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run make compile, then M-x efrit-do with a simple command and verify the agent buffer appears.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:29:56.9455-08:00","updated_at":"2025-12-03T13:17:00.060373-08:00","closed_at":"2025-12-03T13:17:00.060373-08:00"}
{"id":"ef-3pw","title":"Verify error handling and recovery in efrit-do async","description":"User requirement: Error handling must be solid for prime-time release.\n\nAreas to test:\n1. API errors (timeout, rate limit, auth failure) - should not crash, should show clear error\n2. Tool execution errors (bad elisp syntax, command not found) - should be caught and reported\n3. Circuit breaker trips - should show reason and allow recovery\n4. Session interruption (C-g) - should cleanup gracefully\n5. Recovery from errors - can Claude recover or does session need restart?\n\nCurrent implementation:\n- efrit-do--extract-error-info exists for error detection\n- efrit-do--build-error-context exists for context\n- Circuit breaker configured with limits\n- But integration testing needed\n\nTesting needed:\n1. Test bad elisp: (eval_sexp \"invalid lisp\")\n2. Test missing command: (shell_exec \"nonexistent_command\")\n3. Test timeout behavior\n4. Test session interruption\n5. Test recovery from transient errors","acceptance_criteria":"All error scenarios handled gracefully without crashing Emacs. Errors should be clearly displayed in progress buffer. Session should be recoverable or cleanly terminated.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:45.578341-08:00","updated_at":"2025-12-02T20:53:34.563982-08:00","closed_at":"2025-12-02T20:53:34.563982-08:00"}
{"id":"ef-46k","title":"Stream Claude text content to agent buffer","description":"Stream Claude's text responses to the agent buffer for real-time display.\n\nCURRENT STATE:\n- efrit-agent-stream-content and efrit-agent-stream-end exist and work\n- efrit-do-async--on-api-response (line 154) receives API responses\n- Content is a VECTOR of content blocks, each with :type field\n\nIMPLEMENTATION:\n1. In efrit-do-async--on-api-response (line 154-181), after extracting content:\n\n2. Iterate through content blocks and stream text:\n   (dotimes (i (length content))\n     (let ((item (aref content i)))\n       (when (equal (gethash \"type\" item) \"text\")\n         (efrit-agent-stream-content (gethash \"text\" item)))))\n\n3. After the content loop, end the stream:\n   (efrit-agent-stream-end)\n\n4. Add (require 'efrit-agent) at top of file if not already present\n\nIMPORTANT DETAILS:\n- Content blocks are hash tables with \"type\" and \"text\" keys (string keys, not keywords)\n- Use gethash, not plist-get\n- The streaming functions handle buffer existence checks internally\n- Call stream-end after ALL text blocks are processed, not after each one\n\nEXISTING CODE CONTEXT (line 165-167):\n  (when content\n    (efrit-progress-insert-event session-id 'message\n      `((:text . ,(format \"%S\" content)) (:role . \"assistant\"))))\n\nInsert agent buffer calls alongside (not replacing) progress buffer calls.\n\nFILES: lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run efrit-do and verify Claude's text appears in agent buffer as it streams.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:30:06.066463-08:00","updated_at":"2025-12-03T13:18:00.332136-08:00","closed_at":"2025-12-03T13:18:00.332136-08:00","dependencies":[{"issue_id":"ef-46k","depends_on_id":"ef-33f","type":"blocks","created_at":"2025-12-03T12:31:29.223645-08:00","created_by":"daemon"}]}
{"id":"ef-4iw","title":"Show tool start and result in agent buffer","description":"Display tool executions in the agent buffer with start/result updates.\n\nCURRENT STATE:\n- efrit-agent-show-tool-start returns a tool-id (string)\n- efrit-agent-show-tool-result takes tool-id, result, success-p, elapsed\n- Tool execution happens in efrit-do-async--execute-tools (line 183-255)\n\nIMPLEMENTATION:\n1. In efrit-do-async--execute-tools, find the loop that processes tools (line 196)\n\n2. BEFORE tool execution (around line 213), add:\n   (let ((agent-tool-id (efrit-agent-show-tool-start tool-name input))\n         (tool-start-time (current-time)))\n     ;; existing tool execution code here\n     (let* ((tool-result (efrit-do-async--execute-single-tool ...))\n            ...existing code...\n            (elapsed-secs (float-time (time-subtract (current-time) tool-start-time))))\n       ;; AFTER tool completes, add:\n       (efrit-agent-show-tool-result agent-tool-id tool-result (not is-error) elapsed-secs)\n       ;; rest of existing code\n       ))\n\n3. The key variables available in the loop:\n   - tool-name: string like \"Read\" or \"Bash\"\n   - input: hash table of tool input parameters\n   - tool-result: string result from tool execution\n   - is-error: boolean (t if result starts with \"Error \")\n\n4. Wrap the tool execution in timing code to capture elapsed time\n\nEXISTING CODE PATTERN (lines 208-224):\n  ;; Fire progress event\n  (efrit-progress-insert-event session-id 'tool_started ...)\n  ;; Execute tool\n  (let* ((tool-result (efrit-do-async--execute-single-tool ...)))\n    ;; Fire result event  \n    (efrit-progress-insert-event session-id 'tool_result ...))\n\nMirror this pattern for agent buffer calls.\n\nFILES: lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run efrit-do with a command that uses tools, verify tools appear in agent buffer with timing.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-03T12:33:14.72815-08:00","updated_at":"2025-12-03T13:19:09.89796-08:00","closed_at":"2025-12-03T13:19:09.89796-08:00","dependencies":[{"issue_id":"ef-4iw","depends_on_id":"ef-33f","type":"blocks","created_at":"2025-12-03T12:33:22.061496-08:00","created_by":"daemon"}]}
{"id":"ef-4z6","title":"Extract tool dispatch runtime from efrit-do.el to efrit-do-dispatch.el","description":"efrit-do.el (1628 lines) mixes too many concerns:\n- User commands and customization\n- Tool dispatch table and runtime\n- Prompt construction\n- Context and TODO management\n\nefrit-chat-api.el and efrit-executor.el reach into efrit-do for tool execution, creating tight coupling and potential circular dependencies.\n\nExtract to efrit-do-dispatch.el:\n- efrit-do--tool-dispatch-table\n- efrit-do--dispatch-tool\n- efrit-do--execute-tool\n- Pure helpers used only by these (sanitization, error extraction)\n\nThen efrit-chat-api.el and efrit-executor.el can require efrit-do-dispatch instead of efrit-do.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (extract ~200 lines)\n- lisp/core/efrit-chat-api.el (change declare-function)\n- lisp/core/efrit-executor.el (change require)","acceptance_criteria":"1. New efrit-do-dispatch.el with tool dispatch table and execution\n2. efrit-do.el reduced to user-facing commands and state management\n3. efrit-chat-api.el requires efrit-do-dispatch not efrit-do\n4. No circular dependency warnings from byte-compile","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.196113-08:00","updated_at":"2025-12-02T22:47:35.926289-08:00","closed_at":"2025-12-02T22:47:35.926289-08:00"}
{"id":"ef-574","title":"Update README: version mismatch and incomplete tool table","description":"README is out of date:\n\n1. Version shows 0.4.0, code is at 0.4.1\n2. Advertises \"15+ tools\" but efrit-do-schema.el defines ~34 tools\n3. Missing tool categories: todo_write, get_diagnostics, beads_*, checkpoint/restore, show_diff_preview, read_image, format_file, undo_edit","acceptance_criteria":"1. Version updated to 0.4.1 everywhere\n2. Tool table expanded to show all major categories","status":"closed","priority":2,"issue_type":"chore","created_at":"2025-12-02T21:47:45.019345-08:00","updated_at":"2025-12-02T22:06:24.445166-08:00","closed_at":"2025-12-02T22:06:24.445166-08:00"}
{"id":"ef-5t5","title":"Add Claude Code migration guide for Emacs users","description":"For users coming from Claude Code, there's no guide mapping concepts:\n\nClaude Code → Efrit equivalent:\n- Chat sidebar → efrit-chat (limited) or efrit-do (full)\n- Project tools → efrit-do tools (not in chat currently)\n- Diff preview → show_diff_preview tool\n- Agent view → efrit-agent buffer\n- Progress view → Efrit Progress buffer\n- AI-to-AI → Remote queue (MCP)\n\nShould also note what's not yet available.","acceptance_criteria":"Documentation exists mapping Claude Code concepts to Efrit equivalents","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-02T21:47:45.05794-08:00","updated_at":"2025-12-02T23:43:23.020445-08:00","closed_at":"2025-12-02T23:43:23.020445-08:00"}
{"id":"ef-7cb","title":"Add multi-session support to agent buffer","description":"Support multiple concurrent sessions with queue display and session switching.\n\nIMPLEMENTATION:\n1. Track multiple session-ids in efrit-agent-core.el\n2. Add session selector UI (maybe in header-line or sidebar)\n3. Queue display showing pending/running sessions\n4. Keybindings to switch between sessions\n5. Each session gets its own conversation history\n\nNOTE: This is backlog priority - single session works fine for most use cases.\n\nFILES: lisp/interfaces/efrit-agent-core.el, lisp/interfaces/efrit-agent.el","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-03T12:31:17.056471-08:00","updated_at":"2025-12-03T12:31:17.056471-08:00","dependencies":[{"issue_id":"ef-7cb","depends_on_id":"ef-zq8","type":"blocks","created_at":"2025-12-03T12:31:46.566362-08:00","created_by":"daemon"}]}
{"id":"ef-89z","title":"Agentic buffer interface for Efrit","description":"Wire the existing efrit-agent.el buffer implementation into efrit-do-async-loop.el to make it the primary display surface. The agent buffer infrastructure is ~80% complete - it just needs integration with the async execution loop. See docs/ef-9sy-agentic-buffer-plan.md for full analysis.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-03T12:29:39.04643-08:00","updated_at":"2025-12-03T12:32:41.077436-08:00","closed_at":"2025-12-03T12:32:41.077436-08:00"}
{"id":"ef-8o0","title":"Potential timer leak in file watcher callbacks (efrit-remote-queue.el)","description":"In efrit-remote-queue.el line 526, each file system event creates a fire-and-forget timer with run-at-time. Under heavy file I/O or rapid file writes, this could accumulate timer objects that are never tracked or explicitly canceled.\n\nThe timer pattern:\n```\n(run-at-time 0.1 nil #'efrit-remote-queue--process-file file-path)\n```\n\nThis is a one-shot timer (interval=nil), but:\n1. Not tracked in any hash table or variable\n2. Called from a file watcher callback that fires on every file event\n3. Could accumulate hundreds of timers if files are written rapidly\n\nPotential solutions:\n1. Add a debounce mechanism to prevent multiple timers for the same file\n2. Use a timer tracking hash table like async-loop uses\n3. Add a maximum pending timers guard\n\nNote: Low risk since each timer is one-shot, but could affect performance under heavy load.","acceptance_criteria":"When file watcher is under heavy load (100+ files written quickly), verify that pending timers don't accumulate beyond a reasonable threshold (max ~20-30 pending).","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T18:08:31.280075-08:00","updated_at":"2025-12-02T20:55:59.383112-08:00","closed_at":"2025-12-02T20:55:59.383112-08:00"}
{"id":"ef-8o2","title":"Extract shared HTTP/API client layer (efrit-api.el)","description":"Both efrit-chat-api.el and efrit-executor.el duplicate HTTP request building logic:\n- JSON encoding with Unicode escaping\n- Header construction (x-api-key, anthropic-version, content-type)\n- url-retrieve / url-retrieve-synchronously calls\n- Response parsing\n\nCreate efrit-api.el (or extend efrit-common.el) with:\n```elisp\n(defun efrit-api-build-headers (api-key) ...)\n(defun efrit-api-request-async (request-data callback) ...)\n(defun efrit-api-request-sync (request-data \u0026optional timeout) ...)\n```\n\nAlso unify header customization:\n- efrit-custom-headers and efrit-excluded-headers are chat-only but should be shared\n\nFiles affected:\n- lisp/core/efrit-chat-api.el (efrit--build-headers, ~200 lines of HTTP code)\n- lisp/core/efrit-executor.el (efrit-executor--api-request, efrit-executor--sync-api-call)","acceptance_criteria":"1. Single efrit-api-request-async function used by both chat and executor\n2. Header customization (custom/excluded headers) works consistently in both modes\n3. No duplicated JSON encoding or Unicode escaping logic","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.180206-08:00","updated_at":"2025-12-02T22:37:37.783347-08:00","closed_at":"2025-12-02T22:37:37.783347-08:00"}
{"id":"ef-9sy","title":"Agentic buffer interface for Efrit","description":"Design and implement an agentic buffer interface for Efrit, similar to Amp or Claude Code. The current interface relies on efrit-do which takes a command and emits events to a progress buffer. We need a proper interactive buffer-based agent interface that:\n\n- Presents the agent's reasoning, actions, and results in a readable buffer format\n- Allows user interaction (pausing, resuming, modifying instructions mid-task)\n- Integrates with existing tools and APIs we already have\n- Provides better visibility into what the agent is doing\n\nThis would be the primary interface for agentic work, replacing or complementing the current efrit-do command interface.","design":"The agentic buffer should show:\n1. Initial user request/instructions at the top\n2. Agent's reasoning and intermediate steps\n3. Current action being taken\n4. Results of actions\n5. Interactive controls for pausing/resuming\n\nBuild on existing: efrit-chat-buffer.el for display, efrit-tools.el for execution, efrit-do-schema.el for tool definitions","acceptance_criteria":"- Stub issue created with clear vision\n- Initial design decisions documented\n- Technical approach identified","notes":"Implementation tasks created 2025-12-03:\nCORE (P1):\n- ef-33f: Call agent buffer on session start (READY)\n- ef-46k: Stream Claude text content (blocked by ef-33f)\n- ef-4iw: Show tool start/result (blocked by ef-33f)\n- ef-ybp: End session properly (blocked by ef-33f)\n\nINPUT INTEGRATION (P2):\n- ef-r82: Connect input to executor (blocked by core tasks)\n- ef-m0t: Route request_user_input (blocked by ef-r82)\n\nPOLISH (P3-P4):\n- ef-mmy: Syntax highlighting\n- ef-tjd: Collapse/expand defaults\n- ef-zq8: Session persistence\n- ef-7cb: Multi-session support\n\nSee docs/ef-9sy-agentic-buffer-plan.md for full analysis.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-03T10:51:19.741381-08:00","updated_at":"2025-12-03T12:33:28.979785-08:00"}
{"id":"ef-byp","title":"Standardize tool naming between chat and do modes","description":"Inconsistent tool names across modes:\n- buffer_create (do schema) vs create_buffer (chat-tool handling)\n- Chat-only tools (create_buffer, edit_buffer, read_buffer, buffer_info, get_context) not in efrit-do-schema.el\n\nThis makes it hard to reason about \"the set of tools Efrit supports\".\n\nOptions:\n1. Decide on canonical names (prefer existing do schema: buffer_create, buffer_read, etc.)\n2. Add aliases in dispatcher (accept both \"create_buffer\" and \"buffer_create\")\n3. Long-term: derive chat and do schemas from same source\n\nStart with option 2 - add aliases without breaking existing code.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (dispatch table)\n- lisp/core/efrit-do-schema.el (add any missing tools)\n- lisp/core/efrit-chat-api.el (tool handling)","acceptance_criteria":"1. Documented canonical tool naming convention\n2. Both old and new names work via aliases\n3. No behavior change for existing users","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-02T21:58:07.25901-08:00","updated_at":"2025-12-02T23:27:02.989309-08:00","closed_at":"2025-12-02T23:27:02.989309-08:00"}
{"id":"ef-dbe","title":"Add SECURITY.md documenting trust model and Elisp execution risks","description":"Efrit is effectively \"remote code execution in Emacs\" but this isn't clearly documented.\n\nNeed a SECURITY.md (or README section) covering:\n1. Trust model - Efrit trusts Claude/Anthropic with running arbitrary Elisp\n2. What context is sent (user-login-name, home-directory, recent-files, etc.)\n3. Recommended practices (don't run as root, audit shell whitelist, etc.)\n4. Shell command security and remote access implications","acceptance_criteria":"1. SECURITY.md exists with comprehensive coverage\n2. README links to it prominently","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:47:45.039105-08:00","updated_at":"2025-12-02T22:07:14.686839-08:00","closed_at":"2025-12-02T22:07:14.686839-08:00"}
{"id":"ef-dcm","title":"Accept cwd parameter in MCP server beads_command tool","description":"The beads_command tool in mcp/src/server.ts should accept an optional cwd parameter to specify the working directory for bd commands.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-02T21:08:47.210928-08:00","updated_at":"2025-12-02T21:37:50.101945-08:00","closed_at":"2025-12-02T21:37:50.101945-08:00"}
{"id":"ef-e3b","title":"Progress buffer appears automatically in efrit-do async - verify this is working","description":"User requirement: The efrit-do working buffer (progress buffer) should automatically appear when efrit-do starts asynchronous execution.\n\nCurrent code shows:\n- efrit-do-async-show-progress-buffer is set to t\n- efrit-do-async-loop is called with show-progress enabled\n- But this hasn't been manually tested\n\nNeed to:\n1. Verify progress buffer auto-displays when running efrit-do (interactive test)\n2. Verify it can be hidden with efrit-do-silently\n3. Verify it can be shown manually with efrit-do-show-progress\n4. Check that window management works correctly (doesn't break existing layout)","acceptance_criteria":"1. Run efrit-do with a test command, verify progress buffer appears automatically without manual action\n2. Run efrit-do-silently, verify no progress buffer appears\n3. Run efrit-do-show-progress, verify it displays the progress buffer\n4. Verify Emacs window layout is reasonable (doesn't delete user's existing windows)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T18:08:35.397107-08:00","updated_at":"2025-12-02T20:52:55.560788-08:00","closed_at":"2025-12-02T20:52:55.560788-08:00"}
{"id":"ef-h8e","title":"Extract TODO item struct to efrit-todo.el from efrit-do.el","description":"efrit-tools.el declares functions from efrit-do.el for TODO item access:\n- efrit-do-todo-item-status\n- efrit-do-todo-item-priority\n- efrit-do-todo-item-content\n- efrit-do-todo-item-id\n\nThis inverts the dependency: core tools should not depend on workflow-specific code.\n\nCreate efrit-todo.el containing:\n- efrit-do-todo-item struct definition (cl-defstruct)\n- Accessor functions\n- efrit-do--current-todos variable\n- TODO-related helper functions\n\nThen:\n- efrit-do.el requires efrit-todo.el for TODO state management\n- efrit-tools.el requires efrit-todo.el instead of declaring efrit-do functions\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (lines 333-414 - TODO management)\n- lisp/core/efrit-tools.el (lines 61-64 declarations, 826-854 format functions)","acceptance_criteria":"1. efrit-todo.el with struct definition and state management\n2. efrit-tools.el requires efrit-todo.el (no efrit-do declarations)\n3. Cleaner module layering: efrit-todo → efrit-tools → efrit-do","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T21:58:07.22065-08:00","updated_at":"2025-12-02T23:03:24.367937-08:00","closed_at":"2025-12-02T23:03:24.367937-08:00"}
{"id":"ef-i2q","title":"Document when to use efrit-chat vs efrit-do vs efrit-agent","description":"Users (especially those from Claude Code) will be confused about which mode to use:\n\n1. efrit-chat - Multi-turn conversation, buffer-centric tools only\n2. efrit-do - Agentic command execution, full project/file tool suite\n3. efrit-agent - Structured session view for efrit-do\n\nREADME currently doesn't clearly explain:\n- Chat has much smaller tool surface than efrit-do\n- Project-wide refactor/fix workflows should use efrit-do\n- The agent buffer exists and how to use it\n\nThe efrit-agent buffer is one of the nicest parts of Efrit but is never mentioned in README!","acceptance_criteria":"1. README has clear \"When to use\" section explaining each mode\n2. efrit-agent mentioned in Features and Usage sections\n3. Help text improved to guide users to correct mode","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T21:47:45.009469-08:00","updated_at":"2025-12-02T22:05:36.308592-08:00","closed_at":"2025-12-02T22:05:36.308592-08:00"}
{"id":"ef-ibi","title":"Remove backward compatibility cruft from codebase","description":"This is a new codebase - we don't need backward compatibility with older versions.\n\nReview and remove:\n- define-obsolete-function-alias declarations\n- define-obsolete-variable-alias declarations\n- defalias wrappers that exist only for compatibility\n- Comments mentioning deprecated, legacy, backward compatibility\n- Any bridge or adapter code between old/new APIs\n- Variables marked as deprecated (e.g., efrit-api-url in efrit-common.el)\n\nKnown locations to check:\n- lisp/core/efrit-api.el: backward compatibility section at end\n- lisp/core/efrit-common.el: efrit-api-url deprecated variable, efrit-common-truncate-string obsolete alias\n- lisp/core/efrit-chat-api.el: defalias wrappers for efrit--build-headers, efrit--build-tool-result\n\nAfter cleanup:\n- Rename functions to their canonical names (no aliases needed)\n- Remove deprecated variables entirely\n- Update all callers to use the new names directly","acceptance_criteria":"1. No define-obsolete-*-alias in codebase\n2. No defalias used for compatibility (only for genuine semantic aliases)\n3. No deprecated/legacy variables or comments\n4. All functions use their canonical names\n5. make compile passes with no warnings","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-12-02T22:39:04.115703-08:00","updated_at":"2025-12-02T22:40:55.860384-08:00","closed_at":"2025-12-02T22:40:55.860384-08:00"}
{"id":"ef-m0t","title":"Route request_user_input tool to agent buffer","description":"When request_user_input tool runs, show the question in the agent buffer.\n\nCURRENT STATE:\n- efrit-do--handle-request-user-input (efrit-do-handlers.el:567) handles the tool\n- It calls efrit-session-set-pending-question and returns '[WAITING-FOR-USER]'\n- efrit-agent-show-question exists and displays questions with clickable buttons\n- Agent buffer already tracks efrit-agent--pending-question\n\nIMPLEMENTATION OPTIONS:\n\nOPTION A (In tool handler - simpler):\n1. In efrit-do-handlers.el, modify efrit-do--handle-request-user-input (line 567-594)\n2. After setting pending question (line 580-582), add:\n   (require 'efrit-agent)\n   (efrit-agent-show-question question options)\n\nOPTION B (In async loop - more centralized):\n1. In efrit-do-async-loop.el, after tool execution (around line 220)\n2. Detect if tool result contains '[WAITING-FOR-USER]'\n3. Extract question/options from session and call efrit-agent-show-question\n4. This is less clean because question data must be re-fetched from session\n\nRECOMMENDED: Option A is simpler and more direct.\n\nFULL CHANGE for Option A:\nIn efrit-do--handle-request-user-input, after line 582:\n   ;; Show in agent buffer\n   (when (fboundp 'efrit-agent-show-question)\n     (efrit-agent-show-question question options))\n\nUsing fboundp makes it optional - works even if agent module not loaded.\n\nFILES: lisp/interfaces/efrit-do-handlers.el\nVERIFICATION: Run efrit-do with a command like 'ask me a question about colors', verify question appears in agent buffer with options, click an option, verify session continues.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-03T12:30:44.582313-08:00","updated_at":"2025-12-03T13:10:41.234643-08:00","dependencies":[{"issue_id":"ef-m0t","depends_on_id":"ef-r82","type":"blocks","created_at":"2025-12-03T12:31:40.690721-08:00","created_by":"daemon"}]}
{"id":"ef-mch","title":"Elisp eval is unbounded - can hang Emacs with no timeout","description":"efrit-tools-eval-sexp has no timeout or sandbox around Elisp evaluation. A single misgenerated form (infinite while loop, tight recursion, blocking I/O) can freeze Emacs until user hits C-g.\n\nThis is acceptable for advanced users who understand the risk, but:\n1. README doesn't prominently document this risk\n2. No opt-in timeout mechanism exists\n3. No mention of efrit-tools-sexp-evaluation-enabled config option\n\nSUGGESTED FIX:\nAdd optional timeout wrapping with efrit-tools-eval-timeout custom variable.","acceptance_criteria":"1. Configurable timeout for eval_sexp (default on, reasonable value like 30s)\n2. Document the risk in README's security section\n3. Document efrit-tools-sexp-evaluation-enabled as a safety switch","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:47:44.999174-08:00","updated_at":"2025-12-02T22:30:52.445339-08:00","closed_at":"2025-12-02T22:30:52.445339-08:00"}
{"id":"ef-mmy","title":"Add syntax highlighting in tool result code blocks","description":"Add syntax highlighting for code blocks in tool results.\n\nCURRENT STATE:\n- efrit-agent--format-tool-expansion (line 141) formats expanded tool results\n- efrit-agent--format-indented-lines (line 173) handles text formatting\n- Diff highlighting already exists (efrit-agent--format-diff-content)\n- No general code block highlighting yet\n\nIMPLEMENTATION:\n1. In efrit-agent-tools.el, add a new function after line 173:\n\n   (defun efrit-agent--format-code-block (text language indent max-lines)\n     \"Format TEXT as a code block with LANGUAGE syntax highlighting.\"\n     (let* ((mode (intern-soft (concat language \"-mode\")))\n            (highlighted\n             (if (and mode (fboundp mode))\n                 (with-temp-buffer\n                   (insert text)\n                   (funcall mode)\n                   (font-lock-ensure)\n                   (buffer-string))\n               text)))\n       (efrit-agent--format-indented-lines highlighted indent max-lines)))\n\n2. In efrit-agent--format-tool-expansion (around line 158), detect code blocks:\n   - Look for ```language\\n...\\n``` patterns in result\n   - Extract language and content\n   - Call efrit-agent--format-code-block for each\n\n3. Common language mappings:\n   - elisp/emacs-lisp -\u003e emacs-lisp-mode\n   - python/py -\u003e python-mode\n   - javascript/js -\u003e js-mode\n   - bash/sh/shell -\u003e sh-mode\n\nFILES: lisp/interfaces/efrit-agent-tools.el\nVERIFICATION: Run efrit-do with a command that returns code, expand the tool result, verify syntax highlighting.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-03T12:30:54.844161-08:00","updated_at":"2025-12-03T13:11:11.381716-08:00","dependencies":[{"issue_id":"ef-mmy","depends_on_id":"ef-4iw","type":"blocks","created_at":"2025-12-03T12:33:22.144983-08:00","created_by":"daemon"}]}
{"id":"ef-p91","title":"Display actual model name instead of config reference in chat startup message","description":"The efrit-chat buffer startup message displays \"efrit-config\" instead of the actual model name (e.g., \"claude-3-5-sonnet\"). Users want to know which model is actually being used.","acceptance_criteria":"- Startup message shows the actual model identifier being used\n- Model name is resolved from configuration at startup","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-03T10:45:19.340889-08:00","updated_at":"2025-12-03T10:49:02.539644-08:00","closed_at":"2025-12-03T10:49:02.539644-08:00"}
{"id":"ef-phj","title":"Use shell-quote-argument in efrit-tool-beads.el for safer shell command construction","description":"Security fix: The beads tool functions should use shell-quote-argument when constructing shell commands to prevent injection vulnerabilities.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T21:08:47.089095-08:00","updated_at":"2025-12-02T21:09:43.087879-08:00","closed_at":"2025-12-02T21:09:43.087879-08:00"}
{"id":"ef-r82","title":"Connect agent buffer input to session executor","description":"Wire efrit-agent-input-send to route user input to the session system.\n\nCURRENT STATE:\n- efrit-agent-input-send (line 168) only displays the message, doesn't execute\n- Session API exists: efrit-session-respond-to-question, efrit-session-set-pending-question\n- efrit-agent--pending-question tracks pending question in agent buffer\n- efrit-session-active returns the current active session\n\nIMPLEMENTATION:\n1. In efrit-agent-input.el, modify efrit-agent-input-send (around line 168-189)\n\n2. After the existing history/display code (around line 183), add:\n   ;; Route to session if active\n   (let ((session (efrit-session-active)))\n     (when session\n       (if (efrit-session-waiting-for-user-p session)\n           ;; Respond to pending question\n           (progn\n             (efrit-session-respond-to-question session input)\n             (setq efrit-agent--pending-question nil)\n             (efrit-agent-set-status 'working))\n         ;; Ad-hoc guidance - inject into session\n         (efrit-session-add-message session 'user input)\n         (message \"Guidance injected to session\"))))\n\n3. Add requires at top of file:\n   (require 'efrit-session)\n   (require 'efrit-session-worklog)\n\nFUNCTIONS AVAILABLE:\n- (efrit-session-active) - returns current session or nil\n- (efrit-session-waiting-for-user-p session) - t if waiting for input\n- (efrit-session-respond-to-question session response) - clears pending, resumes session\n- (efrit-session-add-message session role text) - adds to conversation history\n\nFILES: lisp/interfaces/efrit-agent-input.el\nVERIFICATION: Run efrit-do with a command that asks a question, type response in agent buffer, verify session continues.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-03T12:30:35.259726-08:00","updated_at":"2025-12-03T13:10:16.660396-08:00","dependencies":[{"issue_id":"ef-r82","depends_on_id":"ef-46k","type":"blocks","created_at":"2025-12-03T12:31:34.782207-08:00","created_by":"daemon"},{"issue_id":"ef-r82","depends_on_id":"ef-ybp","type":"blocks","created_at":"2025-12-03T12:31:34.866561-08:00","created_by":"daemon"},{"issue_id":"ef-r82","depends_on_id":"ef-4iw","type":"blocks","created_at":"2025-12-03T12:33:22.104233-08:00","created_by":"daemon"}]}
{"id":"ef-ri7","title":"Extract prompt strings to dedicated *-prompt.el modules","description":"Large prompt strings bloat logic files:\n\n1. efrit-do.el contains prompt-building functions:\n   - efrit-do--command-examples\n   - efrit-do--command-formatting-tools  \n   - efrit-do--command-common-tasks\n   - efrit-do--command-project-workflow\n   - efrit-do--session-protocol-instructions\n\n2. efrit-tools.el has a massive efrit-tools-system-prompt (~200 lines of string concatenation)\n\nCreate:\n- lisp/core/efrit-do-prompt.el - move all efrit-do--command-* functions\n- lisp/core/efrit-tools-prompt.el - move efrit-tools-system-prompt\n\nThis is low-risk cut/paste that immediately reduces file sizes.\n\nFiles affected:\n- lisp/interfaces/efrit-do.el (currently ~600 lines omitted in analysis suggests more prompt code)\n- lisp/core/efrit-tools.el (lines 590-789 are system prompt)","acceptance_criteria":"1. efrit-do-prompt.el contains all prompt-building functions\n2. efrit-tools-prompt.el contains efrit-tools-system-prompt\n3. Original files reduced by combined ~400 lines\n4. All tests/compilation still pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-02T21:58:07.209916-08:00","updated_at":"2025-12-02T22:14:46.324925-08:00","closed_at":"2025-12-02T22:14:46.324925-08:00"}
{"id":"ef-t57","title":"Chat mode lacks circuit breaker - only bounded by efrit-max-turns","description":"efrit-do has robust circuit breaker with max-tool-calls-per-session and error-loop detection.\n\nefrit-chat only has efrit-max-turns (default 2) and retry-on-error logic.\n\nIf chat tools keep failing, the model can burn tokens retrying with no per-tool loop detection.\n\nLower priority since max-turns provides some protection.","acceptance_criteria":"Either: add lightweight tool-call tracking to chat, OR document that only efrit-do has circuit breaker semantics","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-02T21:47:45.048556-08:00","updated_at":"2025-12-02T23:39:53.577508-08:00","closed_at":"2025-12-02T23:39:53.577508-08:00"}
{"id":"ef-tjd","title":"Improve tool result collapse/expand defaults","description":"Make long tool results collapsed by default.\n\nCURRENT STATE:\n- Tool results are ALREADY collapsed by default (see line 96-97, 136)\n- efrit-agent--update-tool-result sets efrit-tool-expanded to nil\n- The issue is that ALL results are collapsed, even short ones\n\nREVISED GOAL: Auto-expand SHORT results, keep long ones collapsed.\n\nIMPLEMENTATION:\n1. In efrit-agent--update-tool-result (line 79), add logic to auto-expand short results\n\n2. After line 95 (elapsed-time calculation), add length check:\n   (auto-expand (and success-p\n                     (\u003c (length result) 200)\n                     (\u003c (cl-count ?\\n result) 5)))\n\n3. Use auto-expand to set initial state on line 136:\n   efrit-tool-expanded auto-expand\n\n4. If auto-expand is t, render the expanded view immediately instead of collapsed\n\nALTERNATIVE: Add customization variable:\n   (defcustom efrit-agent-auto-expand-short-results t\n     \"Auto-expand tool results shorter than threshold.\"\n     :type boolean :group efrit-agent)\n   (defcustom efrit-agent-short-result-threshold 200\n     \"Results shorter than this are auto-expanded.\"\n     :type integer :group efrit-agent)\n\nFILES: lisp/interfaces/efrit-agent-tools.el\nVERIFICATION: Run efrit-do, verify short results auto-expand, long results stay collapsed.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-03T12:31:01.996737-08:00","updated_at":"2025-12-03T13:11:34.44508-08:00","dependencies":[{"issue_id":"ef-tjd","depends_on_id":"ef-4iw","type":"blocks","created_at":"2025-12-03T12:33:22.186068-08:00","created_by":"daemon"}]}
{"id":"ef-uso","title":"Check for resource leaks in async execution loop","description":"User requirement: No resource leaks before release.\n\nAreas to audit:\n1. Buffer cleanup - are temporary buffers closed after sessions end?\n2. Timer cleanup - are all timers canceled when sessions end?\n3. Hash table cleanup - are session loops removed from tracking?\n4. HTTP connections - are URL requests properly closed?\n5. File handles - are any files left open after operations?\n\nCurrent code analysis shows:\n- efrit-do-async-loop.el properly cleans up via remhash (line 350)\n- Progress buffers may accumulate if many sessions run\n- One-shot timers in callbacks aren't tracked (efrit-do.el:1188, efrit-remote-queue.el:526)\n- Need to verify real cleanup under heavy load\n\nTesting needed:\n1. Run 10+ sequential efrit-do commands, check buffer count\n2. Monitor timer objects with (timer-list)\n3. Check for orphaned processes\n4. Stress test with concurrent commands and queueing\n5. Check memory growth over time","acceptance_criteria":"After running 10+ commands in quick succession, verify: no accumulation of buffers, no orphaned timers, no memory growth, no file descriptor leaks","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-02T18:08:50.308795-08:00","updated_at":"2025-12-02T20:56:50.945684-08:00","closed_at":"2025-12-02T20:56:50.945684-08:00"}
{"id":"ef-whm","title":"efrit-chat-api.el: split API communication from tool handling","description":"efrit-chat-api.el (1077 lines) mixes:\n1. HTTP/API request building and response parsing\n2. Classic chat mode message handling\n3. Streamlined mode implementation\n4. Tool call extraction and execution\n5. UI updates (efrit--display-message, etc.)\n\nAfter extracting shared API client (ef-xxx), consider further splitting:\n- efrit-chat-transport.el: HTTP layer (if not moved to efrit-api.el)\n- efrit-chat-classic.el: Classic multi-turn chat mode\n- efrit-chat-streamlined.el: Streamlined mode (~200 lines starting at line 664)\n\nThis is lower priority since the shared API extraction addresses the main duplication.\n\nFiles affected:\n- lisp/core/efrit-chat-api.el","acceptance_criteria":"1. Clear separation of concerns if split performed\n2. Each file under 400 lines\n3. Tests pass","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-02T21:58:07.267796-08:00","updated_at":"2025-12-02T23:51:24.282539-08:00","closed_at":"2025-12-02T23:51:24.282539-08:00"}
{"id":"ef-xmw","title":"CRITICAL: efrit-chat and efrit-do have very different tool sets - NOT feature parity","description":"CRITICAL ISSUE: efrit-chat only has 8 basic tools while efrit-do has 34 comprehensive tools.\n\nefrit-chat tools (hardcoded in efrit-chat-api.el lines 222-304):\n1. eval_sexp\n2. get_context\n3. resolve_path\n4. read_image\n5. create_buffer\n6. edit_buffer\n7. read_buffer\n8. buffer_info\n\nefrit-do tools (via efrit-do-schema.el):\n- All 8 chat tools PLUS\n- shell_exec\n- todo_write\n- session_complete\n- glob_files\n- request_user_input\n- confirm_action\n- checkpoint/restore\n- show_diff_preview\n- web_search\n- fetch_url\n- project_files\n- search_content\n- read_file\n- edit_file\n- create_file\n- file_info\n- vcs_status/diff/log/blame\n- elisp_docs\n- set_project_root\n- get_diagnostics\n- format_file\n- undo_edit\n- display_in_buffer\n- format_file_list\n- format_todo_list\n\nThis breaks the user requirement that efrit-chat should have access to all the same tools as efrit-do.\n\nBlocker for release until resolved.","acceptance_criteria":"efrit-chat must have access to all 34 tools available in efrit-do, OR the user must be clearly informed that efrit-chat is intentionally limited (not recommended for one-off tasks that need file operations)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-02T18:09:00.3812-08:00","updated_at":"2025-12-02T18:14:46.073883-08:00","closed_at":"2025-12-02T18:14:46.073883-08:00"}
{"id":"ef-xx4","title":"Shell security: ssh/scp/rsync allowed by default - document remote host risk","description":"efrit-do-allowed-shell-commands includes ssh, scp, and rsync by default.\n\nThis means Claude can connect to any host in user's SSH config, copy files to/from remote systems, and execute commands on remote systems.\n\nThe shell security section in README doesn't highlight this remote-host risk.\n\nOPTIONS:\nA) Remove ssh/scp/rsync from default whitelist\nB) Add prominent documentation warning\nC) Add separate remote access tool category","acceptance_criteria":"1. Either: ssh/scp/rsync removed from defaults, OR clear documentation about remote access implications\n2. Warning when using (\"*\") or disabling security","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-02T21:47:45.029476-08:00","updated_at":"2025-12-02T22:07:25.784341-08:00","closed_at":"2025-12-02T22:07:25.784341-08:00"}
{"id":"ef-ybp","title":"End agent session properly on loop completion","description":"Signal session completion to the agent buffer when the async loop ends.\n\nCURRENT STATE:\n- efrit-agent-set-status exists and works with: working, paused, waiting, complete, failed\n- No efrit-agent-end-session function exists yet\n- efrit-do-async--stop-loop (line 319) handles session termination\n\nIMPLEMENTATION:\n\nAPPROACH A (Recommended - Add public function):\n1. In efrit-agent.el, add after efrit-agent-set-status (around line 811):\n   (defun efrit-agent-end-session (success-p)\n     \"End the current agent session.\n   SUCCESS-P determines whether to show complete or failed status.\"\n     (efrit-agent-set-status (if success-p 'complete 'failed)))\n\n2. In efrit-do-async--stop-loop (line 319), add after line 327:\n   (efrit-agent-end-session (string= stop-reason \"end_turn\"))\n\nAPPROACH B (Use set-status directly):\n1. In efrit-do-async--stop-loop, add after line 327:\n   (efrit-agent-set-status\n     (if (string= stop-reason \"end_turn\") 'complete 'failed))\n\nCONTEXT - stop-reason values:\n- \"end_turn\" = Claude finished successfully\n- \"interrupted\" = User interrupted (C-g)\n- \"api-error\" = API call failed\n- \"iteration-limit-exceeded\" = Hit max iterations\n- \"session-complete\" = Tool signaled completion\n- \"unknown-stop-reason\" = Unexpected stop reason\n\nAll non-\"end_turn\" reasons should show 'failed status.\n\nFILES: lisp/interfaces/efrit-agent.el, lisp/interfaces/efrit-do-async-loop.el\nVERIFICATION: Run efrit-do to completion, verify agent buffer shows 'complete' status. Then interrupt with C-g, verify it shows 'failed'.","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-12-03T12:30:25.038094-08:00","updated_at":"2025-12-03T13:19:11.889206-08:00","dependencies":[{"issue_id":"ef-ybp","depends_on_id":"ef-33f","type":"blocks","created_at":"2025-12-03T12:31:29.304746-08:00","created_by":"daemon"}]}
{"id":"ef-zq8","title":"Add session persistence for agent buffer","description":"Save and restore agent buffer conversation when buffer is killed.\n\nCURRENT STATE:\n- efrit-transcript-save saves session to disk\n- efrit-transcript-load loads session by ID\n- efrit-transcript-list returns available transcripts\n- efrit-agent-mode has kill-buffer-hook for cleanup (line 263)\n\nIMPLEMENTATION:\n1. Add save-on-kill in efrit-agent-core.el:\n   - In kill-buffer-hook (already exists), call transcript save\n   - Only save if session has content worth saving\n\n2. Add restore option in efrit-agent-start-session (to be created in ef-33f):\n   - Check if transcript exists for session-id\n   - If exists, prompt: Restore previous session? y/n\n   - If yes, load and replay messages to agent buffer\n\n3. Key functions to use:\n   (efrit-transcript-save session) - saves session\n   (efrit-transcript-load session-id) - returns session struct or nil\n   (efrit-session-conversation-history session) - gets messages\n\n4. Restore flow:\n   (let ((old-session (efrit-transcript-load session-id)))\n     (when (and old-session (y-or-n-p \"Restore previous session? \"))\n       (dolist (msg (efrit-session-conversation-history old-session))\n         (let ((role (nth 0 msg)) (content (nth 1 msg)))\n           (pcase role\n             (user (efrit-agent--add-user-message content))\n             (assistant (efrit-agent--add-claude-message content)))))))\n\nFILES: lisp/interfaces/efrit-agent-core.el, lisp/core/efrit-session-transcript.el\nVERIFICATION: Run efrit-do, let it complete, kill buffer, run efrit-agent, verify restore prompt appears.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-03T12:31:10.055122-08:00","updated_at":"2025-12-03T13:11:58.591188-08:00","dependencies":[{"issue_id":"ef-zq8","depends_on_id":"ef-ybp","type":"blocks","created_at":"2025-12-03T12:31:40.823738-08:00","created_by":"daemon"}]}
{"id":"ef-zsd","title":"Add Beads MCP tool to Efrit","description":"Give Efrit access to beads CLI through MCP server. This allows Efrit to:\n- Check ready work (bd ready)\n- Create issues (bd create)\n- Update issue status (bd update)\n- Close issues (bd close)\n- List and query issues (bd list)\n- Inspect dependencies (bd show)\n\nShould be implemented as an MCP tool in the TypeScript/Node MCP server.","acceptance_criteria":"Efrit can execute beads commands through MCP and receive structured results. At minimum: bd ready, bd create, bd update, bd close, bd list","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-02T18:27:05.1739-08:00","updated_at":"2025-12-02T20:55:12.528625-08:00","closed_at":"2025-12-02T20:55:12.528625-08:00"}
